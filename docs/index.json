[{"categories":["Python"],"content":"文章描述","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"学习自廖雪峰的官方网站–Python教程 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:0:0","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"Python的高级特性 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:0","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"切片 创建一个0-99的数列 \u003e\u003e\u003e L = list(range(100)) \u003e\u003e\u003e L [0, 1, 2, 3, ..., 99] 前10个数： \u003e\u003e\u003e L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： \u003e\u003e\u003e L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： \u003e\u003e\u003e L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： \u003e\u003e\u003e L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： \u003e\u003e\u003e L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 原样复制list \u003e\u003e\u003e L[:] [0, 1, 2, 3, ..., 99] 倒转list \u003e\u003e\u003e L[::-1] [99, 98, 97, 96, ..., 0] tuple切片仍是tuple： \u003e\u003e\u003e (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串也可以当作list来切片 \u003e\u003e\u003e 'ABCDEFG'[:3] 'ABC' \u003e\u003e\u003e 'ABCDEFG'[::2] 'ACEG' ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:1","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"迭代 通过for ... in循环来遍历list或tuple，这种便利称为迭代(iteration)。 迭代dict 默认dict迭代的是key \u003e\u003e\u003e d = {'a': 1, 'b': 2, 'c': 3} \u003e\u003e\u003e for key in d: ... print(key) ... a c b 迭代dict的value \u003e\u003e\u003e for value in d.values(): ... print(value) ... 1 2 3 同时迭代key和value \u003e\u003e\u003e for k, v in d.items(): ... print(k, v) ... b 2 c 3 a 1 判断一个对象是否可迭代 通过collections模块的Iterable类型判断： \u003e\u003e\u003e from collections import Iterable \u003e\u003e\u003e isinstance('abc', Iterable) # str是可迭代对象 True \u003e\u003e\u003e isinstance([1, 2, 3], Iterable) # list是可迭代对象 True \u003e\u003e\u003e isinstance(123, Iterable) # 整数不是可迭代对象 False list实现下标循环 使用Python内置的enumerate函数实现 \u003e\u003e\u003e for i, v in enumerate(['A', 'B', 'C']): ... print(i, v) ... 0 A 1 B 2 C ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:2","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"列表生成式 简单方便的生成list \u003e\u003e\u003e [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] \u003e\u003e\u003e [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] \u003e\u003e\u003e [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] \u003e\u003e\u003e d = {'x': 'A', 'y': 'B', 'z': 'C' } \u003e\u003e\u003e [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] \u003e\u003e\u003e L = ['Hello', 'World', 'IBM', 'Apple'] \u003e\u003e\u003e [s.lower() for s in L] ['hello', 'world', 'ibm', 'apple'] ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:3","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"生成器 把列表生成式的[]改成()就可以创建一个生成器g 通过next(g)打印出来 创建一个斐波拉契数列的生成器 def fib(max): n, a, b = 0, 0, 1 while n \u003c max: yield b a, b = b, a + b n += 1 return 'done' ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:4","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"迭代器 \u003e\u003e\u003e from collections import Iterator \u003e\u003e\u003e isinstance((x for x in range(10)), Iterator) True \u003e\u003e\u003e isinstance([], Iterator) False \u003e\u003e\u003e isinstance({}, Iterator) False \u003e\u003e\u003e isinstance('abc', Iterator) False 凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 from collections import Iterator \u003e\u003e\u003e isinstance(iter([]), Iterator) True \u003e\u003e\u003e isinstance(iter('abc'), Iterator) True ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:5","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"函数式编程 高阶函数 map/reduce map函数：把第一个参数(函数)，作用在第二个参数(Iterable)的每个元素上，并把结果作为新的Iterator返回。 例子: \u003e\u003e\u003e list(map(str, [1, 2, 3, 4, 5, 6, , 7, 8, 9])) ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce函数：第一个参数是函数，第二个参数是序列，函数依次作用于序列的每一个元素，并把结果作用于下一个元素 例子： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) filter 过滤序列。第一个参数是函数，第二个参数是序列，函数依次作用于序列的每一个元素，然后根据返回值True还是False决定保留还是丢弃该元素。 又是惰性的。 def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] sorted sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。 \u003e\u003e\u003e sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] 返回函数 一个函数返回另一个函数，不立即执行，调用时执行。 匿名函数 lambda表达式。 f = lambda x : x * x 装饰器 动态增加函数的功能。 import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s%s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 偏函数 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 \u003e\u003e\u003e import functools \u003e\u003e\u003e int2 = functools.partial(int, base=2) \u003e\u003e\u003e int2('1000000') 64 \u003e\u003e\u003e int2('1010101') 85 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:6","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"面向对象编程 访问限制 定义私有变量，需要在变量前加上两个下划线__，通过get方法获取，或者通过set方法赋值。 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量 强烈不建议这么干，不同版本的Python解释器可能会改成不同的变量名。 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 获取对象信息 type() \u003e\u003e\u003e import types \u003e\u003e\u003e def fn(): ... pass ... \u003e\u003e\u003e type(fn)==types.FunctionType True \u003e\u003e\u003e type(abs)==types.BuiltinFunctionType True \u003e\u003e\u003e type(lambda x: x)==types.LambdaType True \u003e\u003e\u003e type((x for x in range(10)))==types.GeneratorType True isinstance() 判断class的继承关系 也能替代type()判断基本类型 还可以判断一个变量是否是某些类型中的一种 \u003e\u003e\u003e isinstance([1, 2, 3], (list, tuple)) True \u003e\u003e\u003e isinstance((1, 2, 3), (list, tuple)) True dir() 如果要获取一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list. 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:7","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"面向对象高级编程 使用__slots__ 正常可以动态绑定实例的属性和方法，如果在实例中定义一个特殊的__slots__变量，则可以限制该class实例能添加的属性。 使用_slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用。 使用@property Python内置的@property装饰器就是负责把一个方法变成属性调用。 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value \u003c 0 or value \u003e 100: raise ValueError('score must between 0 ~ 100!') self._score = value 如果只定义了get方法，没有定义set方法，就是只读属性 定制类 需要特殊变量 __slots__ __len__ __str__ __repr__ __iter__ __next__ __getitem__ __getattr__ __call__ 使用元类 __metaclass__ 理解难点，找到了一个详细讲解的文章 深刻理解Python中的元类(metaclass) 此文章翻译自stackoverflow的一个神回复 what-is-a-metaclass-in-python ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:8","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"错误、调试、和测试 错误处理 捕获异常并处理 try...except...finally... 主动抛出异常 raise 调试 断言 断言返回False的，则抛出AssertionError assert n != 0, 'n is zero!' 启动Python解释器时可以用-0参数来关闭assert python3 -0 err.py logging pdb 让程序以单步方式运行 以参数-m pdb启动 输入命令n可以单步执行代码 输入命令p 变量名来查看变量 输入命令q结束调试，退出程序 也可以设置断点 需要先import pdb 在需要断点的地方放置pdb.set_trace() ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:9","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"IO编程 StringIO和BytesIO 操作文件和目录 OS模块 \u003e\u003e\u003e import os \u003e\u003e\u003e os.name # 操作系统类型 \u003e\u003e\u003e os.uname() # 详细的系统信息 \u003e\u003e\u003e os.environ() # 系统环境变量 \u003e\u003e\u003e os.path.abspath('.') # 当前目录绝对路径 \u003e\u003e\u003e os.path.join('/Users/Bruce', 'testdir') # 拼接路径 \u003e\u003e\u003e os.mkdir('/Users/Bruce/testdir') # 创建目录 \u003e\u003e\u003e os.rmdir('/Users/Bruce/testdir') # 删除目录 \u003e\u003e\u003e os.path.split('/Users/Bruce/testdir/file.txt') ('/Users/Bruce/testdir', 'file.txt') \u003e\u003e\u003e os.rename('test.txt', 'test.py') # 对文件重命名 \u003e\u003e\u003e os.remove('text'.py') # 删除文件 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:10","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"常用内建模块 datetime collections namedtuple depue defaultdict OrderedDict Counter base64 hashlib itertools count() cycle() repeat() takewhile() chain() groupby() XML DOM SAX HTMLParser urllib ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:11","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"常用第三方模块 PIL PIL:Python Imaging Library，强大的图片处理模块 Pillow，在PIL的基础上创建的兼容的版本 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:12","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"异步IO 协程 没有理解，重点看一下。 asyncio async/await aiohttp ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:13","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"文章描述","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"pip基础命令记录–来源自官方文档 ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:0","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"在线安装第三方库 pip install SomePackage ＃ 最新版本 pip install SomePackage==1.0.4 # 指定版本 pip install SomePackage\u003e=1.0.4 # 最低限度版本 同时会安装依赖的其他第三方库 ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:1","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"需要安装的列表文件 pip install -r requirements.txt ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:2","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"导出已安装的第三方库列表 pip freeze \u003e ./requirements.txt ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:3","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"统一将第三方库安装到用户目录下 pip install --user SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:4","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"移除第三方库 pip uninstall SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:5","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看当前安装的第三方库 pip list ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:6","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查询需要升级的库 pip list --outdated ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:7","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"升级库 pip install --upgrade SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:8","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看库的详细信息 pip show SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:9","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看库的安装信息 pip show --files SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:10","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"在线查找第三方库 pip search \"query\" ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:11","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["DevTools","Python"],"content":"文章描述","date":"2016-08-24","objectID":"/2016/08/python-pyenv/","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"pyenv的使用记录 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:0","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"pyenv的仓库地址 https://github.com/yyuu/pyenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:1","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配合pyenv-virtualenv创建虚拟环境 https://github.com/yyuu/pyenv-virtualenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:2","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装pyenv brew install pyenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:3","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配置pyenv 配置工作目录 export PYENV_ROOT=/usr/local/var/pyenv 添加环境变量 if which pyenv \u003e /dev/null; then eval \"$(pyenv init -)\"; fi ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:4","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装pyenv-virtualenv brew install pyenv-virtualenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:5","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配置pyenv-virtualenv 添加环境变量 if which pyenv-virtualenv-init \u003e /dev/null; then eval \"$(pyenv virtualenv-init -)\"; fi ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:6","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"重新加载SHELL环境，使环境变量生效 exec $SHELL ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:7","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"查看pyenv命令 pyenv commands ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:8","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"查看所有可安装Python版本 pyenv install --list ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:9","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装指定版本 pyenv install 2.7.12 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:10","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"本地指定使用已安装的版本 pyenv local 2.7.12 执行👆命令后，会在当前目录生成一个.python-version文件，用于指定当前目录中所使用的python版本。 如果当前目录没有.python-version文件，则会向上级目录查找，当前目录所使用的python版本，与上级目录指定的版本相同。 如果直到根目录都没有找到.python-version文件，则使用global设置的版本 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:11","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"指定全局版本 pyenv global system system为系统默认python版本，非pyenv安装版本。 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:12","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-08-19","objectID":"/2016/08/git-tools/","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"Git命令使用记录－来源自官方文档 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:0:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"选择修订版本 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"简短的 SHA-1 查看每次提交简短的SHA-1值 git log --abbrev-commit --pretty=oneline 假设某个提交是1c002dd....，如果你想git show这个提交，下面三个命令是等价的（假设简短的版本没有歧义） git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b git show 1c002dd4b536e7479f git show 1c002dd ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"分支引用 如果想查看某个分支的最后一次提交信息，可以使用rev-parse探测出该分支的最后一次SHA-1值 git rev-parse \u003cbranchName\u003e 然后再git show打印出的SHA-1值 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"引用日志 git reflog 如果想查看仓库中HEAD在五次前的所指向的提交 git show HEAD@{5} 如果想查看master分支在昨天的时候指向了哪个提交 git show master@{yesterday} 引用日志只存在于本地仓库，如果查询的时间早于本地最早操作时间，则会显示第一次操作记录 可以运行git log -g来查看类似于git log输出格式的引用日志信息 git log -g master ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:3","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"祖先引用 查看HEAD的上一个提交，也就是“HEAD的父提交”，下面两个命令等价 git show HEAD^ git show HEAD~ 查看HEAD的第二父提交 git show HEAD^2 查看HEAD的第一父提交的第一父提交，下面两个命令等价 git show HEAD^^ git show HEAD~2 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:4","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"提交区间 双点 查看experiment分支中还有哪些提交尚未被合并入master分支 git log master..experiment 查看master分支中存在，而experiment分支中不存在的提交，下面三个命令等价 git log experiment..master git log ^experiment master git log master --not experiment 如果在..的某一边留空，则默认为HEAD 多点 查看所有被refA或refB包含的但是不被refC包含的提交，下面两个命令等价 git log refA refB ^refC git log refA refB --not refC 三点 查看master或者experiment中包含的但不是两者共有的提交 git log master...experiment 如果加上参数--left-right，会显示每个提交到底处于哪一侧的分支 git log --left-right master...experiment ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:5","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"交互式暂存 如果运行git add时使用-i或者--interactive选项，Git将会进入交互式终端模式 git add -i git add --interactive ","date":"2016-08-19","objectID":"/2016/08/git-tools/:2:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"储藏与清理 如果想要切换分支，但是不想提交之前修改的文件，这时需要用到储藏 git stash git stash save 这时就可以轻易的切换分支并在其他地方工作，如果想要查看储藏 git stash list 如果想要重新应用储藏，执行👇命令，如果不指定一个储藏，则默认最近一个 git stash apply git stash apply stash@{2} 重新应用后，之前暂存的文件并没有重新暂存，这时需要--index选项 git stash apply --index 重新应用后，堆栈上的储藏并不会删除，可以使用删除命令 git stash drop stash@{2} 如果想要将储藏重新应用后立即从栈上删除，可以使用👇的命令 git stash pop 如果不想储藏已暂存的文件，需要--keep-index选项 git stash save --keep-index 如果想储藏未跟踪文件，需要--include-untracked或-u选项 git stash save -u 如果指定了--patch标记，Git会交互式的提示储藏 git stash --patch ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"从储藏创建一个分支 如果重新应用储藏时，可能会有冲突，这时可能会想创建一个新分支，并在新分支上重新应用储藏 git stash branch \u003cbranchName\u003e ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"清理工作目录 移除所有未被忽略并且未被追踪的文件，非常危险！ git clean 更安全一些的命令，将所有文件储藏 git stash --all git clean的一些选项 查看git clean将会做什么，-n git clean -n 移除工作目录中所有未追踪的文件以及空的子目录，-d git clean -n -d 强制移除，确定移除，-f git clean -n -d -f 移除.gitignore文件忽略的文件类型，-x git clean -n -d -x -f 以交互模式运行clean命令，-i git clean -x -i ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"特殊合并 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"合并某个分支上的单个commit 假设将feature分支上的commitfdb7b6合并到master分支，不合并其它commit: 先查找想要合并的commit的SHA－1值； 再checkout到想要合并的分支； git checkout master 最后执行cherry-pick命令: git cherry-pick fdb7b6 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"合并某个分支上的一系列commits 假设将feature分支上的commitfdb7b6 至d46ee6合并到master分支 首先，在feature分支基础上创建一个新分支，并且指明最后一个commit git checkout -b newBranch d46ee6 然后，使用rebase命令合并到master分支，要指明合并开始的commit git rebase --onto master fdb7b6^ to be continue... ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["Java"],"content":"文章描述","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["Java"],"content":"问题背景 Java开发中，使用Hibernate作为映射数据库的表，所以创建了一个modle类 @javax.persistence.Entity @javax.persistence.Table(name = \"HibernateTest\") public class HibernateTest extends BaseModel { private static final long serialVersionUID = 9124938173965082237L; private Long id; private String name; private Integer age; @javax.persistence.Id @javax.persistence.GeneratedValue(strategy = javax.persistence.GenerationType.IDENTITY) @javax.persistence.Column(name = \"Id\") public Long getId() { return id; } public void setId(Long id) { this.id = id; } @javax.persistence.Column(name = \"Name\") public String getName() { return name; } public void setName(String name) { this.name = name; } @javax.persistence.Column(name = \"Age\") public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 对应的数据库，由于DBA要求非字符串字段必须有默认值，则 CREATE TABLE `HibernateTest` ( `Id` bigint(16) NOT NULL AUTO_INCREMENT COMMENT '主键', `Name` varchar(32) DEFAULT NULL COMMENT '名称', `Age` int(8) NOT NULL DEFAULT '-1' COMMENT '年龄', PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 这种情况下，使用Hibernate默认的save或update方法来添加或修改数据，如果有非空约束的字段(比如Age)没有赋值，会抛出异常。 因为Hibernate执行save或update时，会将映射类中的所有映射字段加入到生成的SQL语句中，所以导致数据库报错。 ","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/:1:0","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["Java"],"content":"解决方法 在映射类的类名上方，添加注解 @org.hibernate.annotations.Entity(dynamicInsert = true, dynamicUpdate = true) 这样Hibernate在执行save或update方法时，映射类中映射字段为NULL的，就不会加入到最后生成的SQL语句中了。 ","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/:2:0","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-08-16","objectID":"/2016/08/git-basics/","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"Git命令使用记录－来源自官方文档 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:0:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1. Git起步 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1.1 配置文件 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 用户信息 设置用户名称与邮件地址 git config --global user.name \"BruceMaa\" git config --global user.email BruceMaa@example.com 文本编辑器 默认是VIM，可配置为emacs git config --global core.editor emacs 检查配置信息 列出所有Git当时能找到的配置 git config --list Git会将三个位置的配置信息都列出来，所以可能会有重复，如果只想查看当前信息 git config user.name 打开当前仓库的配置文件 git config -e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1.2 获取帮助 若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册: git help \u003cverb\u003e git \u003cverb\u003e --help man git-\u003cverb\u003e 例如，要想获得config命令的手册，执行 git help config ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2. Git基础 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.1 获取Git仓库 在现有目录中初始化仓库 初始化 git init 克隆仓库 克隆 git clone [url] 克隆仓库，自定义本地仓库名字 克隆，自定义本地仓库名字 git clone [url] [newRepo] ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.2 记录每次更新到仓库 检查当前文件状态 git status 跟踪新文件，并将文件暂存 git add file 交互式暂存 git add --interactive 等同于 git add -i 状态简览 git status -s ?? 表示新添加文件，但未跟踪 A 表示新添加文件，并放入暂存区中 左M 表示暂存区的文件已被修改，并放入暂存区中 右M 表示暂存区的文件已被修改，并未放入暂存区中 忽略文件 创建.gitignore文件，列出要忽略的文件模式，可用正则表达式 查看尚未暂存的文件更新了哪些部分 git diff 查看已暂存的文件未提交的更新部分 git diff --staged 提交更新 此命令提交，会显示core.editor设置的编辑器，填写提交信息 git commit 将提交信息于命令放在同一行 git commit -m \"new commit\" 不使用git add命令，将已跟踪过的文件暂存起来一并提交 git commit -a -m \"new commit\" 移除文件 git rm file 记得从工作目录中删除，这样就不会出现在未跟踪文件清单中了,如果已经放到暂存区的话，则要用强制删除选项 -f 从仓库中删除，但本地保留 git rm --cached file 移动文件 git mv file_from file_to ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.3 查看提交历史 git log -p 显示每次提交的内容差异，-2 显示最近两次提交 git log -p -2 –stat 查看每次提交的简略的统计信息 git log --stat –pretty 格式化显示内容，内建子选项 oneline, short, full和fuller git log --pretty=oneline 定制记录格式 git log --pretty=format:\"%h - %an, %ar : %s\" 显示精简SHA－1值 git log --abbrev-commit --pretty=oneline 引用日志 git reflog 查看5次前所指向的提交 git show HEAD@{5} 查看master分支昨天指向哪个提交 git show master@{yesterday} 父引用 需要在引用的后面加上一个^ HEAD的第一次父提交 git show HEAD^ HEAD的第二次父提交 git show HEAD^2 HEAD的第一次父提交的第一次父提交 git show HEAD^^ 等同于 git show HEAD~2 提交区间 双点 查看experiment分支上有哪些提交尚未合并到master分支上 git log master..experiment 查看在master分支中而不在experiment分支中的提交 git log experiment..master 查看即将推送到远端的内容,下面两个相同 git log origin/master..HEAD git log origin/master.. 多点 查看所有被refA或refB包含但是不被refC包含的提交，下面两个相同 git log refA refB ^refC git log refA refB --not refC 三点 查看master或者experiment中包含，但不是两者共有的的提交 git log master...experiment 还可以加参数–left-right，它会显示每一个提交属于哪一个分支 git log --left-right master...experiment format常用选项 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 当oneline或format与另一个log选项–graph结合使用时尤其有用，这个选项添加了一些ASCII字符串来形象的展示分支、合并历史： git log --pretty=format:\"%h %s\" --graph git log 的常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制git log 输出的选项 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令： git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" --before=\"2008-11-01\" --no-merges ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:3","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.4 撤销操作 更改上次提交 上次提交后发现有漏提交文件，将漏提交文件放到暂存区，然后执行命令 git commit --amend 取消暂存的文件 git reset HEAD \u003cfile\u003e 撤消对文件的修改 git checkout -- \u003cfile\u003e 撤消提交 撤消最近一次commit，数字可变。在这之后的commit全部舍弃 git reset --hard HEAD~1 撤消最近一次commit，数字可变，在这之后的commit都变成暂存状态，等待提交 git reset --soft HEAD~1 回滚最后一次提交 git reset --soft HEAD^ ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:4","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.5 远程仓库 查看原创仓库 git remote git remote -v 添加远程仓库 git remote add \u003cshortname\u003e \u003curl\u003e 从远程仓库拉取信息 git fetch \u003cshortname\u003e 从远程仓库抓取信息然后合并远程分支到当前分支 git pull 推送到远程仓库 git push [remote-name] [branch-name] 查看远程仓库 git remote show origin 重命名远程仓库 git remote rename \u003coldName\u003e \u003cnewName\u003e 移除远程仓库 git remote rm \u003cremote-name\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:5","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.6 打标签 列出标签 git tag 可以过滤结果 git tag -l 'v1.0.1*' 创建标签 附注标签 git tag -a v1.0 -m 'version 1.0' 轻量标签 git tag v1.0-rc 查看标签信息 git show \u003ctagName\u003e 后期打标签 git log --pertty=oneline 然后在打标签的命令后面加上该次提交的校验值(可以是部分) git tag -a V1.2 9fceb02 共享标签 git push origin \u003ctagname\u003e 如果想要一次推送很多标签 git push origin --tags 检出标签 git checkout -b \u003cbranchname\u003e \u003ctagname\u003e 删除标签 git push origin --delete tag \u003ctagname\u003e 或者，先本地删除标签，再将空标签推送到远程标签，等同于删除标签 git tag -d \u003ctagname\u003e git push origin :refs/tags/\u003ctagname\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:6","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.7 Git 别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:7","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3 分支 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.1 分支简介 分支创建 在当前所在的分支基础上创建新分支 git branch testing 分支切换 git checkout testing 查看分叉历史 git log --oneline --decorate --graph --all ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.2 分支的新建与合并 新建分支 git checkout -b iss53 等同于下面两条命令 git branch iss53 git checkout iss53 分支的合并 将iss53分支合并到master git checkout master git merge iss53 合并时有冲突 修改冲突后，需要查看文件状态，把未提交的提交 git status 删除分支 git branch -d hotfix ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.3 分支管理 分支列表 git branch 查看每一个分支的最后一次提交 git branch -v 查看哪些分支已经合并到当前分支 git branch --merged 查看所有包含未合并工作的分支 git branch --no-merged 强制删除未合并过的分支 git branch -D testing 重命名本地分支 git branch -m \u003coldBranchName\u003e \u003cnewBranchName\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:3","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.3 远程分支 查看远程仓库的远程分支 git ls-remote origin 推送本地分支到远程仓库 git push (remote) (branch) 推送本地分支到远程仓库，并且取不同名字 git push (remote) (local_branch):(new_branch) 跟踪分支 git checkout --track origin/serverfix 修改正在跟踪的上游分支 git branch -u origin/newBranch 或 git branch --set-upstream-to origin/newBranch 查看所有跟踪分支 git branch -vv 如果有显示远程分支显示，并且有ahead提示，则有未推送到远程分支，有behind则表示远程服务器有提交未合并到本地，都没有则表示和远程分支同步； 如果没有显示远程分支，则表示未跟踪远程分支。 如果想查看最新情况，则需要先抓取所有远程仓库，再查看: git fetch --all 拉取 git pull 等同于 git fetch;git merge 删除远程分支 git push origin --delete \u003cdelBranch\u003e 或者，推送一个空分支到远程分支，等同于删除远程分支 git push origin :\u003cdelBranch\u003e 删除本地仓库中，远程已经删除的分支 远程删除了某个分支，本地执行抓取或者拉取时，并不会将本地对应的该分支也一并删除，使用 git remote show origin 命令查看时，正常的跟踪分支状态为tracked，已删除的分支状态为stale，并且Git提示可以使用命令删除 git remote prune 还有一种简单的命令 git fetch -p ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:4","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.4 变基 变基的基本操作 检出新分支，coding git checkout experiment 变基到想要合并的分支 git rebase master 回到master分支 git checkout master 快进合并 git merge experiment 多重分支变基 从master分支创建server分支，再从server创建client分支，现在想先将client分支变基到master分支,再快进合并： git rebase --onto master server client git checkout master git merge client 再将server分支变基到master分支，再快进合并 git rebase master server git merge server 不需切换分支，直接变基某个分支 git rebase [basebranch] [topicbranch] ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:5","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"}]