[{"categories":["BigData"],"content":"文章描述","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"背景 背景 最近由于工作需要，转入大数据开发，由于之前只是片面的了解，近期开始系统的学习。 从Hadoop开始，之后会继续学习Hive、HBase、Storm、Spark、Flink、CarbonData等知识。 ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:1:0","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"目的 本篇文章介绍了如何设置和配置单节点Hadoop3安装，以便您可以使用Hadoop MapReduce和Hadoop分布式文件系统（HDFS）快速执行简单的操作。 ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:2:0","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"前期准备 ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:3:0","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"操作系统 Linux，CentOS7.4，关闭防火墙，或者打开对应端口 systemctl stop firewalld systemctl disable firewalld ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:3:1","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"必要软件 在Linux操作系统中必须包含的软件： 必须安装Java，推荐的Java版本描述位置在HadoopJavaVersions。 如果要使用启动和停止脚本，则必须安装ssh并且必须运行sshd才能使用管理远程Hadoop守护程序的脚本。 ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:3:2","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"安装软件 如果你的环境没有安装必要的软件，则需要安装。 安装ssh yum install -y sshd systemctl start sshd 配置ssh密钥，免密码登陆本服务器。 执行如下命令生成密钥： ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa 命令完成后会在~/.ssh/路径下生成两个文件，id_rsa密钥文件，id_rsa.pub对应的公钥文件。 将公钥文件的信息追加到~/.ssh/authorized_keys文件中，如果没有则新建。 cat ~/.ssh/id_rsa.pub \u003e\u003e ~/.ssh/authorized_keys 之后要修改权限属性 chmod 0600 ~/.ssh/authorized_keys 验证是否配置成功 ssh localhost 第一次验证的时候会提示输入yes或no，直接输入yes即可。 如果输入了yes之后回车，可以进入，就表示配置成功。 安装Java 在此我们安装Java8，下载地址使用清华大学开源软件镜像站。 wget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_hotspot_8u282b08.tar.gz 安装Java并配置JAVA_HOME mkdir -p /usr/local/java tar -xzvf OpenJDK8U-jdk_x64_linux_hotspot_8u282b08.tar.gz -C /usr/local/java/ ln -sf /usr/local/java/jdk8u282-b08/ /usr/local/java/default echo 'export JAVA_HOME=/usr/local/java/default' \u003e\u003e /etc/profile echo 'export PAHT=$PATH:$JAVA_HOME/bin' \u003e\u003e /etc/profile source /etc/profile ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:3:3","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"下载Hadoop3 wget https://mirrors.bfsu.edu.cn/apache/hadoop/common/stable/hadoop-3.3.0.tar.gz ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:4:0","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"准备启动Hadoop 解压下载的Hadoop压缩包到指定位置 mkdir -p /usr/local/hadoop tar -xzvf hadoop-3.3.0.tar.gz -C /usr/local/hadoop ln -sf /usr/local/hadoop/hadoop-3.3.0 /usr/local/hadoop/default 配置JAVA_HOME 进入到Hadoop的根目录下，编辑环境变量配置文件/etc/hadoop/hadoop-env.sh export JAVA_HOME=/usr/local/java/default ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:5:0","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"伪分布式运行（单节点运行） ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:6:0","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"配置 进入到/usr/local/hadoop/default目录下 编辑etc/hadoop/core-site.xml文件 \u003cconfiguration\u003e \u003cproperty\u003e \u003cname\u003efs.defaultFS\u003c/name\u003e \u003cvalue\u003ehdfs://localhost:9000\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e 编辑etc/hadoop/hdfs-site.xml文件 \u003cconfiguration\u003e \u003cproperty\u003e \u003cname\u003edfs.replication\u003c/name\u003e \u003cvalue\u003e1\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:6:1","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"运行HDFS 格式化 bin/hdfs namenode -format 开启NameNode进程和DataNode进程 sbin/start-dfs.sh 运行此命令后，在Hadoop2时直接成功，在Hadoop3时报错。 HDFS_NAMENODE_USER和HDFS_DATANODE_USER和HDFS_SECONDARYNAMENODE_USER没有被定义，所以需要再去配置。 编辑$HADOOP_HOME/libexec/hadoop-config.sh，在文件的上方插入如下配置 HDFS_DATANODE_USER=root HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 重新执行启动dfs命令。 启动后，可以通过Java的jps命令，查看当前运行的Java进程，会看到 19056 DataNode 20466 Jps 18920 NameNode 19304 SecondaryNameNode 表示启动成功（进程ID不一定相同）。 3. 在浏览器上访问NameNode http://localhost:9870/ 在HDFS中创建目录 bin/hdfs dfs -mkdir /user 停止HDFS进程 sbin/stop-dfs.sh ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:6:2","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"运行YARN 编辑配置文件 etc/hadoop/mapred-site.xml \u003cconfiguration\u003e \u003cproperty\u003e \u003cname\u003emapreduce.framework.name\u003c/name\u003e \u003cvalue\u003eyarn\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003emapreduce.application.classpath\u003c/name\u003e \u003cvalue\u003e$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e etc/hadoop/yarn-site.xml \u003cconfiguration\u003e \u003cproperty\u003e \u003cname\u003eyarn.nodemanager.aux-services\u003c/name\u003e \u003cvalue\u003emapreduce_shuffle\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003eyarn.nodemanager.env-whitelist\u003c/name\u003e \u003cvalue\u003eJAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e 启动ResourceManager和NodeManager sbin/start-yarn.sh 运行此命令后，在Hadoop2时直接成功，在Hadoop3时报错。 YARN_RESOURCEMANAGER_USER和YARN_NODEMANAGER_USER没有被定义，所以需要再去配置。 编辑$HADOOP_HOME/libexec/yarn-config.sh，在文件的上方插入如下配置 YARN_RESOURCEMANAGER_USER=root YARN_NODEMANAGER_USER=root 重新执行启动yarn命令。 启动后，可以通过Java的jps命令，查看当前运行的Java进程，会看到 19056 DataNode 20466 Jps 18920 NameNode 19304 SecondaryNameNode 19999 ResourceManager 20143 NodeManager 表示启动成功（进程ID不一定相同）。 3. 在浏览器上访问ResourceManager http://localhost:8088/ 停止YARN进程 sbin/stop-yarn.sh ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:6:3","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["BigData"],"content":"TIPS 如果每次启动或者关闭都要执行两个脚本，太麻烦了，所以Hadoop自带了执行全部的脚本。 启动 sbin/start-all.sh 停止 sbin/stop-all.sh ","date":"2021-03-01","objectID":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/:6:4","tags":["Hadoop"],"title":"Hadoop3单机伪分布式部署","uri":"/2021/03/hadoop3-standalone-pseudo-distributed-mode-setup/"},{"categories":["经济","转载"],"content":"原则","date":"2021-02-22","objectID":"/2021/02/how-the-economic-machine-works/","tags":["视频","经济"],"title":"经济是如何运行的","uri":"/2021/02/how-the-economic-machine-works/"},{"categories":["经济","转载"],"content":"经济是如何运行的 ","date":"2021-02-22","objectID":"/2021/02/how-the-economic-machine-works/:1:0","tags":["视频","经济"],"title":"经济是如何运行的","uri":"/2021/02/how-the-economic-machine-works/"},{"categories":["经济","转载"],"content":"英文语音，中文字幕 ","date":"2021-02-22","objectID":"/2021/02/how-the-economic-machine-works/:1:1","tags":["视频","经济"],"title":"经济是如何运行的","uri":"/2021/02/how-the-economic-machine-works/"},{"categories":["经济","转载"],"content":"中文语音，中文字幕 ","date":"2021-02-22","objectID":"/2021/02/how-the-economic-machine-works/:1:2","tags":["视频","经济"],"title":"经济是如何运行的","uri":"/2021/02/how-the-economic-machine-works/"},{"categories":["经济","转载"],"content":"【基德】经济是如何运行的？ 这是一个适合所有人观看的经济学入门视频 ","date":"2021-02-22","objectID":"/2021/02/how-the-economic-machine-works/:2:0","tags":["视频","经济"],"title":"经济是如何运行的","uri":"/2021/02/how-the-economic-machine-works/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-12","objectID":"/2017/06/lintcode-balanced-binary-tree/","tags":["Algorithm"],"title":"平衡二叉树","uri":"/2017/06/lintcode-balanced-binary-tree/"},{"categories":["lintcode"],"content":"lintcode 访问路径 http://www.lintcode.com/zh-cn/problem/balanced-binary-tree/ ","date":"2017-06-12","objectID":"/2017/06/lintcode-balanced-binary-tree/:1:0","tags":["Algorithm"],"title":"平衡二叉树","uri":"/2017/06/lintcode-balanced-binary-tree/"},{"categories":["lintcode"],"content":"描述 给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 ","date":"2017-06-12","objectID":"/2017/06/lintcode-balanced-binary-tree/:1:1","tags":["Algorithm"],"title":"平衡二叉树","uri":"/2017/06/lintcode-balanced-binary-tree/"},{"categories":["lintcode"],"content":"样例 给出二叉树 A={3,9,20,#,#,15,7}, B={3,#,20,15,7} A) 3 B) 3 / \\ \\ 9 20 20 / \\ / \\ 15 7 15 7 二叉树A是高度平衡的二叉树，但是B不是 ","date":"2017-06-12","objectID":"/2017/06/lintcode-balanced-binary-tree/:1:2","tags":["Algorithm"],"title":"平衡二叉树","uri":"/2017/06/lintcode-balanced-binary-tree/"},{"categories":["lintcode"],"content":"Java代码实现 /** * Definition of TreeNode: * public class TreeNode { * public int val; * public TreeNode left, right; * public TreeNode(int val) { * this.val = val; * this.left = this.right = null; * } * } */ public class Solution { /** * @param root: The root of binary tree. * @return: True if this Binary tree is Balanced, or false. */ public boolean isBalanced(TreeNode root) { // write your code here return maxDepth(root) != -1; } private int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = maxDepth(root.left); int right = maxDepth(root.right); if (left == -1 || right == -1 || Math.abs(left - right) \u003e 1) { return -1; } return Math.max(left, right) + 1; } } ","date":"2017-06-12","objectID":"/2017/06/lintcode-balanced-binary-tree/:1:3","tags":["Algorithm"],"title":"平衡二叉树","uri":"/2017/06/lintcode-balanced-binary-tree/"},{"categories":["lintcode"],"content":"Python代码实现 \"\"\" Definition of TreeNode: class TreeNode: def __init__(self, val): self.val = val self.left, self.right = None, None \"\"\" class Solution: \"\"\" @param root: The root of binary tree. @return: True if this Binary tree is Balanced, or false. \"\"\" def isBalanced(self, root): # write your code here balanced, _ = self.validate(root) return balanced def validate(self, root): if root is None: return True, 0 balanced, left = self.validate(root.left) if not balanced: return False, 0 balanced, right = self.validate(root.right) if not balanced: return False, 0 return abs(left - right) \u003c 2, max(left, right) + 1 ","date":"2017-06-12","objectID":"/2017/06/lintcode-balanced-binary-tree/:1:4","tags":["Algorithm"],"title":"平衡二叉树","uri":"/2017/06/lintcode-balanced-binary-tree/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-12","objectID":"/2017/06/lintcode-add-digits/","tags":["Algorithm"],"title":"各位相加","uri":"/2017/06/lintcode-add-digits/"},{"categories":["lintcode"],"content":"lincode 访问地址 http://www.lintcode.com/zh-cn/problem/add-digits/ ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-digits/:1:0","tags":["Algorithm"],"title":"各位相加","uri":"/2017/06/lintcode-add-digits/"},{"categories":["lintcode"],"content":"描述 给出一个非负整数num，反复的将所有位上的数字相加，直到得到一个一位的整数。 ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-digits/:1:1","tags":["Algorithm"],"title":"各位相加","uri":"/2017/06/lintcode-add-digits/"},{"categories":["lintcode"],"content":"样例 给出num = 38。 相加的过程如下：3 + 8 = 11, 1 + 1 = 2。因为2只剩下一个数字，所以返回2。 ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-digits/:1:2","tags":["Algorithm"],"title":"各位相加","uri":"/2017/06/lintcode-add-digits/"},{"categories":["lintcode"],"content":"Java代码实现 public class Solution { /** * @param num a non-negative integer * @return one digit */ public int addDigits(int num) { // Write your code here if (num == 0) { return 0; } int temp = 0; for (; num != 0;) { int digit = num % 10; temp = (temp * 10 + digit) % 9; num = num / 10; } return temp == 0 ? 9 : temp; } } ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-digits/:1:3","tags":["Algorithm"],"title":"各位相加","uri":"/2017/06/lintcode-add-digits/"},{"categories":["lintcode"],"content":"Python代码实现 class Solution: # @param {int} num a non-negative integer # @return {int} one digit def addDigits(self, num): # Write your code here if num == 0: return 0 temp = 0 while num != 0: digit = num % 10 temp = (temp * 10 + digit) % 9 num = num / 10 return 9 if temp == 0 else temp ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-digits/:1:4","tags":["Algorithm"],"title":"各位相加","uri":"/2017/06/lintcode-add-digits/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-12","objectID":"/2017/06/lintcode-add-binary/","tags":["Algorithm"],"title":"二进制求和","uri":"/2017/06/lintcode-add-binary/"},{"categories":["lintcode"],"content":"lincode 访问地址 http://www.lintcode.com/zh-cn/problem/add-binary/ ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-binary/:1:0","tags":["Algorithm"],"title":"二进制求和","uri":"/2017/06/lintcode-add-binary/"},{"categories":["lintcode"],"content":"描述 给定两个二进制字符串，返回他们的和（用二进制表示）。 ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-binary/:1:1","tags":["Algorithm"],"title":"二进制求和","uri":"/2017/06/lintcode-add-binary/"},{"categories":["lintcode"],"content":"样例 a = 11 b = 1 返回 100 ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-binary/:1:2","tags":["Algorithm"],"title":"二进制求和","uri":"/2017/06/lintcode-add-binary/"},{"categories":["lintcode"],"content":"Java代码实现 public class Solution { /** * @param a a number * @param b a number * @return the result */ public String addBinary(String a, String b) { // Write your code here if (a.length() \u003c b.length()) { String tmp = a; a = b; b = tmp; } int pa = a.length() - 1; int pb = b.length() - 1; int carries = 0; String rst = \"\"; while (pb \u003e= 0) { int sum = (int) (a.charAt(pa) - '0') + (int) (b.charAt(pb) - '0') + carries; rst = String.valueOf(sum % 2) + rst; carries = sum / 2; pa--; pb--; } while (pa \u003e= 0) { int sum = (int) (a.charAt(pa) - '0') + carries; rst = String.valueOf(sum % 2) + rst; carries = sum / 2; pa--; } if (carries == 1) { rst = \"1\" + rst; } return rst; } } ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-binary/:1:3","tags":["Algorithm"],"title":"二进制求和","uri":"/2017/06/lintcode-add-binary/"},{"categories":["lintcode"],"content":"Python代码实现 class Solution: # @param {string} a a number # @param {string} b a number # @return {string} the result def addBinary(self, a, b): # Write your code here lena = len(a) - 1 lenb = len(b) - 1 temp = 0 result = \"\" while lena \u003e= 0 or lenb \u003e= 0: x = int(a[lena]) if lena \u003e= 0 else 0 y = int(b[lenb]) if lenb \u003e= 0 else 0 sum = x + y + temp result = str(sum % 2) + result temp = sum / 2 lena, lenb = lena - 1, lenb - 1 if temp \u003e 0: result = \"1\" + result return result ","date":"2017-06-12","objectID":"/2017/06/lintcode-add-binary/:1:4","tags":["Algorithm"],"title":"二进制求和","uri":"/2017/06/lintcode-add-binary/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"lintcode 访问路径 http://www.lintcode.com/zh-cn/problem/a-b-problem/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/:1:0","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"描述 给出两个整数a和b, 求他们的和, 但不能使用+等数学运算符。 注意事项 你不需要从输入流读入数据，只需要根据aplusb的两个参数a和b，计算他们的和并返回就行。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/:1:1","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"说明 a和b都是32位整数么？ 是的 我可以使用位运算符么？ 当然可以 ","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/:1:2","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"样例 如果a=1并且b=2，返回3 ","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/:1:3","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"Java代码实现 class Solution { /* * param a: The first integer * param b: The second integer * return: The sum of a and b */ public int aplusb(int a, int b) { // write your code here, try to do it without arithmetic operators. if (b == 0) { return a; } return aplusb(a ^ b, (a \u0026 b) \u003c\u003c 1); } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/:1:4","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"Python代码实现 class Solution: \"\"\" @param a: The first integer @param b: The second integer @return: The sum of a and b \"\"\" def aplusb(self, a, b): # write your code here, try to do it without arithmetic operators. if b == 0: return a if a == 0: return b while b != 0: carry = (a \u0026 b) \u003c\u003c 1 a = a ^ b b = carry return a 注意：由于有[100,-100]这个参数，所以会超时！ ","date":"2017-06-09","objectID":"/2017/06/lintcode-a-b-problem/:1:5","tags":["Algorithm"],"title":"A + B 问题","uri":"/2017/06/lintcode-a-b-problem/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-classical-binary-search/","tags":["Algorithm"],"title":"经典二分查找问题","uri":"/2017/06/lintcode-classical-binary-search/"},{"categories":["lintcode"],"content":"lintcode 访问路径 http://www.lintcode.com/zh-cn/problem/classical-binary-search/# ","date":"2017-06-09","objectID":"/2017/06/lintcode-classical-binary-search/:1:0","tags":["Algorithm"],"title":"经典二分查找问题","uri":"/2017/06/lintcode-classical-binary-search/"},{"categories":["lintcode"],"content":"描述 在一个排序数组中找一个数，返回该数出现的任意位置，如果不存在，返回-1 ","date":"2017-06-09","objectID":"/2017/06/lintcode-classical-binary-search/:1:1","tags":["Algorithm"],"title":"经典二分查找问题","uri":"/2017/06/lintcode-classical-binary-search/"},{"categories":["lintcode"],"content":"样例 给出数组 [1, 2, 2, 4, 5, 5]. 对于 target =2, \u0008返回 1 或者 2. 对于 target =5, \u0008返回 4 或者 5. 对于 target =6, \u0008返回 -1. ","date":"2017-06-09","objectID":"/2017/06/lintcode-classical-binary-search/:1:2","tags":["Algorithm"],"title":"经典二分查找问题","uri":"/2017/06/lintcode-classical-binary-search/"},{"categories":["lintcode"],"content":"Java代码实现 public class Solution { /** * @param nums: An integer array sorted in ascending order * @param target: An integer * @return an integer */ public int findPosition(int[] nums, int target) { // Write your code here if (nums == null || nums.length == 0) { return -1; } int begin = 0; int end = nums.length - 1; while (begin \u003c end) { int mid = (begin + end) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003e target) { end = mid - 1; } else { begin = mid + 1; } } return -1; } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-classical-binary-search/:1:3","tags":["Algorithm"],"title":"经典二分查找问题","uri":"/2017/06/lintcode-classical-binary-search/"},{"categories":["lintcode"],"content":"Python代码实现 class Solution: # @param {int[]} A an integer array sorted in ascending order # @param {int} target an integer # @return {int} an integer def findPosition(self, A, target): # Write your code here if A is None or len(A) == 0: return -1 begin = 0 end = len(A) - 1 while begin \u003c end: mid = (begin + end) / 2 if A[mid] == target: return mid elif A[mid] \u003e target: end = mid - 1 else: begin = mid + 1 return -1 ","date":"2017-06-09","objectID":"/2017/06/lintcode-classical-binary-search/:1:4","tags":["Algorithm"],"title":"经典二分查找问题","uri":"/2017/06/lintcode-classical-binary-search/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"lintcode 访问地址 http://www.lintcode.com/zh-cn/problem/sort-integers/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/:1:0","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"描述 给一组整数，按照升序排序，使用选择排序，冒泡排序，插入排序或者任何 O(n2) 的排序算法。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/:1:1","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"样例 对于数组[3, 2, 1, 4, 5], 排序后为[1, 2, 3, 4, 5]。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/:1:2","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"直接插入排序 Java代码实现 public class Solution { /** * @param A an integer array * @return void */ public void sortIntegers(int[] A) { // Write your code here int length = A.length; int insertNum; for (int i = 1; i \u003c length; i++) { insertNum = A[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 A[j] \u003e insertNum) { A[j + 1] = A[j]; j--; } A[j + 1] = insertNum; } } } Python代码实现 class Solution: # @param {int[]} A an integer array # @return nothing def sortIntegers(self, A): # Write your code here length = len(A) for i in range(1, length): key = A[i] j = i - 1 while j \u003e= 0 and A[j] \u003e key: A[j + 1] = A[j] j -= 1 A[j + 1] = key return A ","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/:1:3","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"选择排序 Java代码实现 public class Solution { /** * @param A an integer array * @return void */ public void sortIntegers(int[] A) { // Write your code here int length = A.length; for (int i = 0; i \u003c length; i++) { int key = A[i]; int position = i; for (int j = i + 1; j \u003c length; j++) { if (A[j] \u003c key) { key = A[j]; position = j; } } A[position] = A[i]; A[i] = key; } } } Python代码实现 class Solution: # @param {int[]} A an integer array # @return nothing def sortIntegers(self, A): # Write your code here length = len(A) for i in range(0, length): min = i for j in range(i + 1, length): if A[min] \u003e A[j]: min = j A[min], A[i] = A[i], A[min] return A ","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/:1:4","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"冒泡排序 Java代码实现 public class Solution { /** * @param A an integer array * @return void */ public void sortIntegers(int[] A) { // Write your code here int length = A.length; int temp; for (int i = 0; i \u003c length; i++) { for (int j = i + 1; j \u003c length; j++) { if (A[i] \u003e A[j]) { temp = A[i]; A[i] = A[j]; A[j] = temp; } } } } } Python代码实现 class Solution: # @param {int[]} A an integer array # @return nothing def sortIntegers(self, A): # Write your code here length = len(A) for i in range(0, length): for j in range(i + 1, length): if A[i] \u003e A[j]: A[i], A[j] = A[j], A[i] return A ","date":"2017-06-09","objectID":"/2017/06/lintcode-sort-integers/:1:5","tags":["Algorithm"],"title":"整数排序","uri":"/2017/06/lintcode-sort-integers/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-remove-linked-list-elements/","tags":["Algorithm"],"title":"删除链表中的元素","uri":"/2017/06/lintcode-remove-linked-list-elements/"},{"categories":["lintcode"],"content":"lintcode 访问地址 http://www.lintcode.com/zh-cn/problem/remove-linked-list-elements/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-remove-linked-list-elements/:1:0","tags":["Algorithm"],"title":"删除链表中的元素","uri":"/2017/06/lintcode-remove-linked-list-elements/"},{"categories":["lintcode"],"content":"描述 删除链表中等于给定值val的所有节点。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-remove-linked-list-elements/:1:1","tags":["Algorithm"],"title":"删除链表中的元素","uri":"/2017/06/lintcode-remove-linked-list-elements/"},{"categories":["lintcode"],"content":"样例 给出链表1-\u003e2-\u003e3-\u003e3-\u003e4-\u003e5-\u003e3, 和 val =3, 你需要返回删除3之后的链表：1-\u003e2-\u003e4-\u003e5。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-remove-linked-list-elements/:1:2","tags":["Algorithm"],"title":"删除链表中的元素","uri":"/2017/06/lintcode-remove-linked-list-elements/"},{"categories":["lintcode"],"content":"Java代码实现 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { /** * @param head a ListNode * @param val an integer * @return a ListNode */ public ListNode removeElements(ListNode head, int val) { // Write your code here ListNode dummy = new ListNode(-1); dummy.next = head; head = dummy; while (head.next != null) { if (head.next.val == val) { head.next = head.next.next; } else { head = head.next; } } return dummy.next; } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-remove-linked-list-elements/:1:3","tags":["Algorithm"],"title":"删除链表中的元素","uri":"/2017/06/lintcode-remove-linked-list-elements/"},{"categories":["lintcode"],"content":"Python代码实现 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # @param head, a ListNode # @param val, an integer # @return a ListNode def removeElements(self, head, val): # Write your code here if head is None: return head dummy = ListNode(-1) dummy.next = head pre = dummy while head: if head.val == val: pre.next = head.next else: pre = pre.next head = head.next return dummy.next ","date":"2017-06-09","objectID":"/2017/06/lintcode-remove-linked-list-elements/:1:4","tags":["Algorithm"],"title":"删除链表中的元素","uri":"/2017/06/lintcode-remove-linked-list-elements/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-rectangle-area/","tags":["Algorithm"],"title":"矩阵面积","uri":"/2017/06/lintcode-rectangle-area/"},{"categories":["lintcode"],"content":"lincode 访问路径 http://www.lintcode.com/zh-cn/problem/rectangle-area/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-rectangle-area/:1:0","tags":["Algorithm"],"title":"矩阵面积","uri":"/2017/06/lintcode-rectangle-area/"},{"categories":["lintcode"],"content":"描述 实现一个矩阵类Rectangle，包含如下的一些成员变量与函数： 两个共有的成员变量width和height分别代表宽度和高度。 一个构造函数，接受2个参数width和height来设定矩阵的宽度和高度。 一个成员函数 getArea，返回这个矩阵的面积。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-rectangle-area/:1:1","tags":["Algorithm"],"title":"矩阵面积","uri":"/2017/06/lintcode-rectangle-area/"},{"categories":["lintcode"],"content":"样例 Rectangle rec = new Rectangle(3, 4); rec.getArea(); // should get 12 ","date":"2017-06-09","objectID":"/2017/06/lintcode-rectangle-area/:1:2","tags":["Algorithm"],"title":"矩阵面积","uri":"/2017/06/lintcode-rectangle-area/"},{"categories":["lintcode"],"content":"Java代码实现 public class Rectangle { /* * Define two public attributes width and height of type int. */ // write your code here public int width; public int height; /* * Define a constructor which expects two parameters width and height here. */ // write your code here public Rectangle(int width, int height) { this.width = width; this.height = height; } /* * Define a public method `getArea` which can calculate the area of the * rectangle and return. */ // write your code here public int getArea() { return this.width * this.height; } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-rectangle-area/:1:3","tags":["Algorithm"],"title":"矩阵面积","uri":"/2017/06/lintcode-rectangle-area/"},{"categories":["lintcode"],"content":"Python代码实现 class Rectangle: def __init__(self, width, height): self.width = int(width) self.height = int(height) def get_area(self): return self.width * self.height ","date":"2017-06-09","objectID":"/2017/06/lintcode-rectangle-area/:1:4","tags":["Algorithm"],"title":"矩阵面积","uri":"/2017/06/lintcode-rectangle-area/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-fibonacci/","tags":["Algorithm"],"title":"斐波纳契数列","uri":"/2017/06/lintcode-fibonacci/"},{"categories":["lintcode"],"content":"lintcode 访问路径 http://www.lintcode.com/zh-cn/problem/fibonacci/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-fibonacci/:1:0","tags":["Algorithm"],"title":"斐波纳契数列","uri":"/2017/06/lintcode-fibonacci/"},{"categories":["lintcode"],"content":"描述 查找斐波纳契数列中第 N 个数。 所谓的斐波纳契数列是指： 前2个数是 0 和 1 。 第 i 个数是第 i-1 个数和第i-2 个数的和。 斐波纳契数列的前10个数字是： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ... 注意事项 在测试事例中，第n个斐波那契数不会超过32位字节整数的最大值。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-fibonacci/:1:1","tags":["Algorithm"],"title":"斐波纳契数列","uri":"/2017/06/lintcode-fibonacci/"},{"categories":["lintcode"],"content":"样例 给定 1，返回 0 给定 2，返回 1 给定 10，返回 34 ","date":"2017-06-09","objectID":"/2017/06/lintcode-fibonacci/:1:2","tags":["Algorithm"],"title":"斐波纳契数列","uri":"/2017/06/lintcode-fibonacci/"},{"categories":["lintcode"],"content":"Java代码实现 class Solution { /** * @param n: an integer * @return an integer f(n) */ public int fibonacci(int n) { // write your code here int a = 0; int b = 1; for (int i = 0; i \u003c n - 1; i++) { int c = a + b; a = b; b = c; } return a; } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-fibonacci/:1:3","tags":["Algorithm"],"title":"斐波纳契数列","uri":"/2017/06/lintcode-fibonacci/"},{"categories":["lintcode"],"content":"Python代码实现 class Solution: # @param n: an integer # @return an integer f(n) def fibonacci(self, n): # write your code here a = 0 b = 1 for i in range(n - 1): a, b = b, a + b return a ","date":"2017-06-09","objectID":"/2017/06/lintcode-fibonacci/:1:4","tags":["Algorithm"],"title":"斐波纳契数列","uri":"/2017/06/lintcode-fibonacci/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-add-two-numbers/","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-add-two-numbers/"},{"categories":["lintcode"],"content":"lintcode 访问地址 http://www.lintcode.com/zh-cn/problem/add-two-numbers/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-add-two-numbers/:1:0","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-add-two-numbers/"},{"categories":["lintcode"],"content":"描述 你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-add-two-numbers/:1:1","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-add-two-numbers/"},{"categories":["lintcode"],"content":"样例 给出两个链表3-\u003e1-\u003e5-\u003enull和5-\u003e9-\u003e2-\u003enull，返回8-\u003e0-\u003e8-\u003enull。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-add-two-numbers/:1:2","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-add-two-numbers/"},{"categories":["lintcode"],"content":"Java代码实现 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { /** * @param l1: the first list * @param l2: the second list * @return: the sum list of l1 and l2 */ public ListNode addLists(ListNode l1, ListNode l2) { // write your code here if (l1 == null \u0026\u0026 l2 == null) { return null; } ListNode head = new ListNode(0); ListNode ptr = head; int carry = 0; while (true) { if (l1 != null) { carry += l1.val; l1 = l1.next; } if (l2 != null) { carry += l2.val; l2 = l2.next; } ptr.val = carry % 10; carry = carry / 10; if (l1 != null || l2 != null || carry != 0) { ptr.next = new ListNode(0); ptr = ptr.next; } else { break; } } return head; } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-add-two-numbers/:1:3","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-add-two-numbers/"},{"categories":["lintcode"],"content":"Python代码实现 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # @param l1: the first list # @param l2: the second list # @return: the sum list of l1 and l2 def addLists(self, l1, l2): # write your code here head = ListNode(0) ptr = head carry = 0 while True: if l1 is not None: carry += l1.val l1 = l1.next if l2 is not None: carry += l2.val l2 = l2.next ptr.val = carry % 10 carry = carry / 10 if l1 is not None or l2 is not None or carry != 0: ptr.next = ListNode(0) ptr = ptr.next else: break return head ","date":"2017-06-09","objectID":"/2017/06/lintcode-add-two-numbers/:1:4","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-add-two-numbers/"},{"categories":["lintcode"],"content":"文章描述","date":"2017-06-09","objectID":"/2017/06/lintcode-binary-tree-maximum-node/","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-binary-tree-maximum-node/"},{"categories":["lintcode"],"content":"lintcode 访问路径 http://www.lintcode.com/zh-cn/problem/binary-tree-maximum-node/ ","date":"2017-06-09","objectID":"/2017/06/lintcode-binary-tree-maximum-node/:1:0","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-binary-tree-maximum-node/"},{"categories":["lintcode"],"content":"描述 在二叉树中寻找值最大的节点并返回。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-binary-tree-maximum-node/:1:1","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-binary-tree-maximum-node/"},{"categories":["lintcode"],"content":"样例 给出如下一颗二叉树： 1 / \\ -5 2 / \\ / \\ 0 3 -4 -5 返回值为3的节点。 ","date":"2017-06-09","objectID":"/2017/06/lintcode-binary-tree-maximum-node/:1:2","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-binary-tree-maximum-node/"},{"categories":["lintcode"],"content":"Java代码实现 public class Solution { /** * @param root the root of binary tree * @return the max ndoe */ public TreeNode maxNode(TreeNode root) { // Write your code here if (root == null) return root; TreeNode left = maxNode(root.left); TreeNode right = maxNode(root.right); return max(root, max(left, right)); } TreeNode max(TreeNode a, TreeNode b) { if (a == null) return b; if (b == null) return a; if (a.val \u003e b.val) return a; return b; } } ","date":"2017-06-09","objectID":"/2017/06/lintcode-binary-tree-maximum-node/:1:3","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-binary-tree-maximum-node/"},{"categories":["lintcode"],"content":"Python代码实现 class Solution: # @param {TreeNode} root the root of binary tree # @return {TreeNode} the max node def maxNode(self, root): # Write your code here if root is None: return None left = self.maxNode(root.left) right = self.maxNode(root.right) return self.max(root, self.max(left, right)) def max(self, a, b): if a is None: return b if b is None: return a if a.val \u003e b.val: return a return b ","date":"2017-06-09","objectID":"/2017/06/lintcode-binary-tree-maximum-node/:1:4","tags":["Algorithm"],"title":"二叉树的最大节点","uri":"/2017/06/lintcode-binary-tree-maximum-node/"},{"categories":["Linux"],"content":"文章描述","date":"2017-04-25","objectID":"/2017/04/linux-command-record-logrotate/","tags":["logrotate"],"title":"Linux记录之logrotate","uri":"/2017/04/linux-command-record-logrotate/"},{"categories":["Linux"],"content":"名称 logrotate - 轮询，压缩，并且邮件系统日志 ","date":"2017-04-25","objectID":"/2017/04/linux-command-record-logrotate/:1:0","tags":["logrotate"],"title":"Linux记录之logrotate","uri":"/2017/04/linux-command-record-logrotate/"},{"categories":["Linux"],"content":"概要 logrotate [-dv] [-f|--force] [-s|--state file] config_file+ ","date":"2017-04-25","objectID":"/2017/04/linux-command-record-logrotate/:2:0","tags":["logrotate"],"title":"Linux记录之logrotate","uri":"/2017/04/linux-command-record-logrotate/"},{"categories":["Linux"],"content":"描述 logrotate旨在简化生成大量日志文件的系统的管理。 它允许自动旋转，压缩，删除和邮寄日志文件。 每个日志文件可能会每天，每周，每月或更长时间处理。 通常，logrotate作为日常的cron作业运行。 除非该日志的标准基于日志的大小，并且logrotate每天运行多次，否则不会在一天内多次修改日志，或者除非使用**-f**或**-force**选项。 可以在命令行中给出任意数量的配置文件。 稍后的配置文件可能会覆盖早期文件中给出的选项，因此logrotate配置文件的列出顺序很重要。 通常，应该使用包含所需的任何其他配置文件的单个配置文件。 有关如何使用include指令来完成此操作的更多信息，请参阅下文。 如果在命令行中指定了目录，该目录中的每个文件都将被用作配置文件。 如果没有给出命令行参数，logrotate将打印版本和版权信息，以及一个简短的使用摘要。 如果在旋转日志时发生任何错误，logrotate将退出非零状态。 ","date":"2017-04-25","objectID":"/2017/04/linux-command-record-logrotate/:3:0","tags":["logrotate"],"title":"Linux记录之logrotate","uri":"/2017/04/linux-command-record-logrotate/"},{"categories":["Linux"],"content":"选项 -v, — —verbose 打开详细模式。 -d, — — debug 打开调试模式，并表示**-v**。 在调试模式下，不会对日志或**logrotate**状态文件进行任何更改。 -f, — —force 告诉logrotate强制旋转，即使它不认为这是必要的。 有时，在将新条目添加到logrotate之后，或者如果旧的日志文件已被手动删除，则新文件将被创建，并且日志记录将继续正常。 -m, ——mail 告诉logrotate在发送日志时使用哪个命令。 该命令应接受两个参数： 消息主题， 收件人。 然后，该命令必须在标准输入上读取消息并将其邮寄给收件人。 默认邮件命令为**/bin/mail -s**。 -s, ——state 告诉logrotate使用备用状态文件。 如果以不同的日志文件集合的不同用户运行logrotate，这将非常有用。 默认状态文件为/var/lib/logrotate/status。 ——usage 打印一个短的使用信息。 ","date":"2017-04-25","objectID":"/2017/04/linux-command-record-logrotate/:4:0","tags":["logrotate"],"title":"Linux记录之logrotate","uri":"/2017/04/linux-command-record-logrotate/"},{"categories":["Linux"],"content":"配置文件 logrotate从命令行中指定的一系列配置文件读取应该处理的日志文件的所有内容。 每个配置文件都可以设置全局选项（本地定义覆盖全局选项，后面的定义会覆盖较早的定义），并指定要旋转的日志文件。 一个简单的配置文件如下所示： # sample logrotate configuration file compress /var/log/messages { rotate 5 weekly postrotate /sbin/killall -HUP syslogd endscript } \"/var/log/httpd/access.log\" /var/log/httpd/error.log { rotate 5 mail www@my.org size=100k sharedscripts postrotate /sbin/killall -HUP httpd endscript } /var/log/news/news.crit { monthly rotate 2 olddir /var/log/news/old missingok postrotate kill -HUP ‘cat /var/run/inn.pid‘ endscript nocompress } 前几行设置全局选项; 在该示例中，日志在旋转后被压缩。 请注意，任一行上的第一个非空白字符为＃则为注释，可能会显示在配置文件的任何位置。 配置文件的下一部分定义了如何处理日志文件/var/log/messages。 日志将被删除之前经过五周轮换。 日志文件旋转后（但在旧版本的日志已压缩之前），命令/ sbin / killall -HUP syslogd将被执行。 下一节将定义/var/log/httpd/access.log和/var/log/httpd/error.log的参数。 当它们的长度超过100k时，它们被旋转，并且旧的日志文件在经过5次旋转之后被邮寄（未压缩）到www@my.org，而不是被移除。 sharedscripts意味着postrotate脚本只能运行一次（在旧日志被压缩之后），而不是一次旋转的每个日志。 请注意，本节开头的第一个文件名的双引号允许logrotate在名称中旋转具有空格的日志。 普通shell引用规则适用，支持'，‘和\\字符。 最后一节定义/ var / log / news中所有文件的参数。 每个文件每月轮换一次。 这被认为是一个单循环指令，如果多于一个文件发生错误，则日志文件不会被压缩。 请谨慎使用通配符。 如果指定*，则logrotate将旋转所有文件，包括以前旋转的文件。 这样做的方法是使用olddir指令或更精确的通配符（例如* .log）。 以下是有关可以包含在logrotate配置文件中的指令的更多信息： compress 日志文件的旧版本默认使用gzip进行压缩。另请参见nocompress。 compresscmd 指定用于压缩日志文件的命令。 默认是gzip。 另见compress。 uncompresscmd 指定用于解压缩日志文件的命令。 默认是gunzip。 compressext 指定在压缩日志文件中使用的扩展名，如果启用压缩。 默认值为配置的压缩命令。 compressoptions 如果有一个正在使用，命令行选项可能会被传递到压缩程序。 gzip的默认值为“-9”（最大压缩）。 copy 制作日志文件的副本，但不要更改原始文件。 例如，可以使用此选项来创建当前日志文件的快照，或者某些其他实用程序需要截断或修剪文件时使用此选项。 使用此选项时，create选项将不起作用，因为旧日志文件保持原样。 copytruncate 在创建副本后，将原始日志文件截断，而不是移动旧的日志文件，并可选择创建一个新的日志文件。当某些程序无法关闭其日志文件时，可以使用它，因此可能会永远写入（附加）到 以前的日志文件。 请注意，在复制文件和截断文件之间存在非常小的时间片段，因此某些对数据可能会丢失。 使用此选项时，create选项将不起作用，因为旧日志文件保持原样。 create mode owner group 在旋转之后（运行postrotate脚本之前），立即创建日志文件（与刚刚旋转的日志文件的名称相同）。 mode指定八进制日志文件的模式（与chmod相同），owner指定拥有日志文件的用户名，group指定日志文件所属的组。 可以省略任何日志文件属性，在这种情况下，新文件的这些属性将使用与原始日志文件相同的值作为省略的属性。 可以使用nocreate选项禁用此选项。 daily 日志文件每天都会旋转。 dateext 存档旧版本的日志文件，添加像YYYYMMDD这样的日常扩展，而不是简单地添加一个数字。可以使用dateformat选项配置扩展。 dateformat format_string 使用类似于strftime函数的符号指定dateext的扩展名。只允许％Y％m％d和％s说明符。默认值为 - ％Y％m％d。请注意，扩展名中分隔日志名称的字符也是dateformat字符串的一部分。系统时钟必须设置为2001年9月9日，以便％s正常工作。请注意，以此格式生成的日期戳记必须是可排序的（即，首先是年份，然后是当天的月份），例如，2001/12/01可以，但01/12/2001不是，因为01/11 / 2002年将排序较低，会在最后）。这是因为当使用rotate选项时，logrotate会对所有旋转的文件名进行排序，以查找哪些日志文件较旧，应该删除。 delaycompress 将上一个日志文件的压缩推迟到下一个旋转周期。 这仅在与compress组合使用时才起作用。 当某些程序无法关闭其日志文件时，可以使用它，因此可能会持续写入以前的日志文件一段时间。 extension ext 日志文件在旋转后被赋予最终扩展名ext。 如果使用压缩，则分机后会出现压缩扩展（通常为**.gz**）。 ifempty 旋转日志文件即使它是空的，覆盖notifempty选项（ifempty是默认的）。 include 文件或目录 读取作为参数给出的文件，就好像它被包含在include指令出现的inline中一样。 如果给出了一个目录，则该目录中的大多数文件将按照字母顺序读取，然后继续处理包含文件。 唯一被忽略的文件是不是常规文件（例如目录和命名管道）的文件以及其名称以tabooext指令指定的禁用扩展名之一的文件。 include指令可能不会出现在日志文件定义内。 mail address 当一个日志被旋转出来，它被邮寄到地址。 如果特定日志不要生成邮件，则可以使用nomail指令。 mailfirst 使用mail命令时，邮寄刚刚转动的文件，而不是即将到期的文件。 maillast 使用mail命令时，邮寄即将到期的文件，而不是刚刚转动的文件（这是默认值）。 maxage count 删除长于天的旋转日志。仅当日志文件要旋转时，才会检查该时间。如果配置了maillast和mail，这些文件将邮寄到配置的地址。 minsize size 当日志文件长度大于字节大小时，日志文件将被旋转，但不会在额外指定的时间间隔（daily, weekly, monthly, or yearly）之间旋转。相关的size选项是相似的，除了它与时间间隔选项相互排斥，并且它导致日志文件被旋转而不考虑最后的旋转时间。当使用minsize时，会考虑日志文件的大小和时间戳。 missingok 如果日志文件丢失，请转到下一个文件，不会发出错误消息。 另见nomissingok。 monthly 日志文件在一个月内首次运行logrotate（这通常在月的第一天）旋转。 nocompress 旧版本的日志文件不会用gzip压缩。 另见compress。 nocopy 不要复制原始日志文件并将其保留。 （这覆盖copy选项）。 nocopytruncate 创建副本后，请勿将原始日志文件截断（这将覆盖copytruncate选项）。 nocreate 不会创建新的日志文件（这将覆盖create选项）。 nodelaycompress 不要将上一个日志文件的压缩推迟到下一个循环周期（这覆盖了delaycompress选项）。 nodateext 不将旧版本的日志文件添加日期扩展名（这将覆盖dateext选项）。 nomail 不要将旧的日志文件邮寄到任何地址。 nomissingok 如果日志文件不存在，则发出错误。 这是默认的。 noolddir 日志在日志通常所在的同一目录中旋转（这覆盖了olddir选项）。 nosharedscripts 为每个旋转的脚本运行prerotate和postrotate脚本（这是默认值，并覆盖sharedscripts选项）。 notifempty 如果日志为空，则不要旋转日志（这将覆盖ifempty选项）。 olddir directory 日志被移动到目录中进行旋转。 该目录必须与正在旋转的日志文件位于相同的物理设备上，并且假定为相对于保存日志文件的目录，除非指定了绝对路径名。 当使用此选项时，所有旧版本的日志最终在目录中。 该选项可能被noolddir选项覆盖。 postrotate/endscript 在旋转日志文件之后，执行postrotate和endscript（两者都必须出现在行上）之间的命令。 这些指令只能出现在日志文件定义的内部。 另见prerotate。 prerotate/endscript prerotate和e","date":"2017-04-25","objectID":"/2017/04/linux-command-record-logrotate/:5:0","tags":["logrotate"],"title":"Linux记录之logrotate","uri":"/2017/04/linux-command-record-logrotate/"},{"categories":["Linux"],"content":"文章描述","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Linux"],"content":"名称 ssh — — OpenSSH SSH 客户端（远程登录程序） ","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/:1:0","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Linux"],"content":"概要 ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command] ","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/:2:0","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Linux"],"content":"描述 ssh (SSH客户端) 是一个登录到远程机器的程序，在远程机器上执行命令。它旨在通过不安全的网络在两个不受信任的主机之间提供安全的加密通信。X11连接，任意TCP端口和UNIX域套接字也可以通过安全通道转发。 ssh连接并登录到指定的主机名（具有可选的用户名）。用户必须使用以下几种方法之一向远程机器证明他/她的身份（见下文）。 如果指定了命令，它将在远程机器执行。 选项如下： -1 强制ssh只尝试协议版本1. -2 强制ssh只尝试协议版本2. -4 强制ssh只使用IPv4. -6 强制ssh只使用IPv6. -A 启用认证代理连接的转发。这也可以在配置文件中的每个主机的基础上进行指定。 应该小心启用代理转发。能够绕过远程主机的文件权限的用户（对于代理的UNIX域套接字）可以通过转发的连接访问本地代理。 攻击者无法从代理获取密钥资料，但是他们可以对密钥执行操作，使其能够使用加载到代理中的身份进行身份验证。 -a 禁用认证代理连接的转发。 -b bind_address 在本地机器上使用bind_address作为连接的源地址。 仅对具有多个地址的系统有用。 -C 请求压缩所有数据（包括stdin，stdout，stderr和转发的X11，TCP和UNIX域连接的数据）。 压缩算法与gzip使用的压缩算法相同，level可以由协议版本1的CompressionLevel选项控制。调制解调器线路和其他慢速连接需要压缩，但在快速网络上只会减慢。 默认值可以在配置文件中逐个主机设置; 请参阅压缩选项。 -c cipher_spec 选择加密会话的密码规范。 协议版本1允许指定单个密码。 支持的值为3des，blowfish和des。 对于协议版本2，cipher_spec是以优先级顺序列出的以逗号分隔的密码列表。 有关详细信息，请参阅ssh_config中的Ciphers关键字。 -D [bind_address:]port 指定本地dynamic应用级端口转发。 这可以通过分配一个套接字来侦听本地端口，可选地绑定到指定的bind_address。 无论何时连接到该端口，连接将通过安全通道转发，然后应用程序协议用于确定从远程机器连接到何处。 目前支持SOCKS4和SOCKS5协议，ssh将作为SOCKS服务器。 只有root可以转发特权端口。 动态端口转发也可以在配置文件中指定。 可以通过将地址括在方括号中来指定IPv6地址。 只有超级用户可以转发特权端口。 默认情况下，根据GatewayPorts设置绑定本地端口。 但是，可以使用显式的bind_address将连接绑定到特定的地址。 localhost的bind_address表示侦听端口仅限于本地使用，而空的地址或*表示端口应该从所有接口可用。 -E log_file 将调试日志追加到log_file而不是标准错误。 -e escape_char 使用pty（默认值：’〜’）设置会话的转义字符。转义字符只能在行的开始处被识别。 转义字符后跟一个点（’.’）关闭连接; 其次是control-Z挂起连接; 然后自己发送一次转义字符。 将字符设置为none可禁用任何转义，并使会话完全透明。 -F configfile 指定一个替代每个用户的配置文件。 如果在命令行中给出了一个配置文件，系统范围的配置文件（/etc/ssh/ssh_config）将被忽略。 每个用户配置文件的默认值为**〜/.ssh/config**。 -f 请求ssh在命令执行之前转到后台。 如果ssh要求密码或密码短语，但用户在后台需要它时，这很有用。 这与 -n 参数相同。 在远程站点启动X11程序的推荐方法是像ssh -f host xterm。 如果ExitOnForwardFailure配置选项设置为yes，则以-f开头的客户端将在将其自身置于后台之前等待所有远程端口的转发成功建立。 -G 导致ssh在评估主机和匹配块并退出后打印其配置。 -g 允许远程主机连接到本地转发的端口。 如果在多路复用连接上使用，则必须在主进程上指定此选项。 -I smartcard_device 指定ssh应使用的设备与用于存储用户私有RSA密钥的智能卡进行通信。此选项仅在对智能卡设备的支持进行编译时可用（默认为不支持）。 -i identity_file 选择一个读取用于公钥认证的身份（私钥）的文件。协议版本1的默认路径为**〜/.ssh/identity**，协议版本号为**〜/.ssh/id_dsa**，**〜/.ssh/id_ecdsa**，**〜/.ssh/id_ed25519**和**〜/.ssh/id_rsa**。身份文件也可以在每个主机的基础上在配置文件中指定。可以有多个**-i**选项（在配置文件中指定多个标识）。如果**CertificateFile**指令没有明确指定任何证书，**ssh**还将尝试从通过将**-cert.pub**追加到身份文件名获取的文件名加载证书信息。 -J [user@]host[:port] 首先通过与跳转主机建立ssh连接，然后从那里建立TCP转发到最终目的地，连接到目标主机。可以用逗号分隔指定多级跳跃。 这是指定ProxyJump配置指令的快捷方式。 -K 启用GSSAPI认证和转发（委派）GSSAPI凭据给服务器。 -k 禁止向服务器转发（委派）GSSAPI凭据。 -L [bind_address:]port:host:hostport [bind_address:]port:remote_socket local_socket:host:hostport local_socket:remote_socket 指定与本地（客户端）主机上的给定TCP端口或Unix套接字的连接将转发到远程端的给定主机和端口或Unix套接字。这可以通过分配套接字来侦听本地的TCP端口，可选地绑定到指定的bind_address或Unix套接字。无论何时连接到本地端口或套接字，连接将通过安全通道转发，并从远程机器连接到主机端口主机端口或Unix套接字remote_socket。 端口转发也可以在配置文件中指定。 只有超级用户可以转发特权端口。 可以通过将地址括在方括号中来指定IPv6地址。 默认情况下，根据GatewayPorts设置绑定本地端口。 但是，可以使用显式的bind_address将连接绑定到特定的地址。localhost的bind_address表示侦听端口仅限于本地使用，而空的地址或*表示端口应该从所有接口可用。 -l login_name 指定用户在远程机器上登录。 这也可以在每个主机的基础上在配置文件中指定。 -M 将ssh客户端置于master模式下进行连接共享。 多个**-M**选项将**ssh**置于master模式，在接受从属连接之前需要确认。 有关详细信息，请参阅ssh_config中的**ControlMaster**的说明。 -m mac_spec 以逗号分隔的MAC（消息认证码）算法列表，以优先级顺序指定。 有关更多信息，请参阅MACs关键字。 -N 不要执行远程命令。 这对于转发端口是有用的。 -n 从**/dev/null**重定向stdin（实际上，阻止从stdin读取）。当ssh在后台运行时，必须使用它。 一个常见的技巧是使用它来在远程机器上运行X11程序。例如，**ssh -n shadows.cs.hut.fi emacs＆**将在shadows.cs.hut.fi上启动一个emacs，X11连接将通过加密通道自动转发。ssh程序将放在后台。 （如果ssh需要输入密码或口令，则此操作不起作用;另请参阅**-f**选项。） -O ctl_cmd 控制主动连接复用主控制程序。 当指定**-O**选项时，**ctl_cmd**参数被解释并传递给主进程。有效的命令是：check（检查主进程是否正在运行），forward（请求转发而不执行命令），cancel（取消转发），exit （主机退出）和stop（请求主机停止接受进一步的复用请求）。 -o option 可用于以配置文件中使用的格式提供选项。 这对于指定没有单独的命令行标志的选项很有用。 有关下列选项的完整详细信息及其可能的值，请参阅ssh_config。 AddKeysToAgent AddressFamily BatchMode BindAddress CanonicalDomains CanonicalizeFallbackLocal CanonicalizeHostname CanonicalizeMaxDots CanonicalizePermittedCNAMEs CertificateFile ChallengeResponseAuthentication CheckHostIP Cipher Ciphers ClearAllForwardings Compression CompressionLevel ConnectionAttempts ConnectTimeout ControlMaster ControlPath ControlPersist DynamicForward EscapeChar ExitOnForwardFailure FingerprintHash ForwardAgent ForwardX11 ForwardX11Timeout ForwardX11Trusted GatewayPorts GlobalKnownHostsFile GSSAPIAuthentication ","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/:3:0","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Linux"],"content":"验证 OpenSSH SSH客户端支持SSH协议1和2.默认是仅使用协议2，尽管可以通过ssh_config中的Protocol选项或**-1**和**-2**选项（见上文）来更改。 不过协议1不应该被使用，只用于支持旧设备。 它存在许多加密缺陷，并且不支持协议2可用的许多高级功能。 可用于认证的方法是：基于GSSAPI的身份验证，基于主机的身份验证，公钥认证，质询 - 响应认证和密码认证。 验证方法按照上面指定的顺序进行尝试，但可以使用PreferredAuthentications更改默认顺序。 基于主机的身份验证的工作原理如下：如果用户登录的机器在远程机器上的**/etc/hosts.equiv**或**/etc/shosts.equiv**中列出，并且用户名在两侧都相同，或者 文件**〜/.rhosts**或**〜/.shosts**存在于远程计算机上的用户主目录中，并包含一行包含客户端计算机的名称和该计算机上用户的名称，该用户被认为是登录。 另外，服务器**必须**能够验证客户端的主机密钥（请参阅下面的**/etc/ssh/ssh_known_hosts**和**〜/.ssh/known_hosts**的描述）以供登录才能被允许。 此认证方法由于IP欺骗，DNS欺骗和路由欺骗而关闭安全漏洞。 [管理员的注意事项：**/etc/hosts.equiv**，**〜/.rhosts**和rlogin/rsh协议一般来说，本质上是不安全的，如果需要安全性，则应该被禁用。] 公开密钥认证的工作原理如下：该方案基于公钥加密，使用密码系统，使用单独的密钥完成加密和解密，从加密密钥中导出解密密钥是不可行的。 这个想法是每个用户创建一个公钥/私钥对用于认证。 服务器知道公钥，只有用户知道私钥。 ssh使用DSA，ECDSA，Ed25519或RSA算法之一自动实现公钥认证协议。 ssl的HISTORY部分简要讨论了DSA和RSA算法。 文件**〜/.ssh/authorized_keys**列出允许登录的公钥。当用户登录时，**ssh**程序会告知服务器要使用哪个密钥对进行身份验证。 客户端证明它可以访问私钥，并且服务器检查相应的公钥是否被授权接受该帐户。 用户通过运行ssh-keygen创建他/她的密钥对。 这将私钥存储在**〜/.ssh/identity**（协议1），**〜/.ssh/id_dsa**（DSA），**〜/.ssh/id_ecdsa**（ECDSA），**〜/.ssh/id_ed25519**（Ed25519）或**〜/.ssh/id_rsa**（RSA），并将公钥存储在**〜/.ssh/identity.pub**（协议1），**〜/.ssh/id_dsa.pub**（DSA），**〜/.ssh/id_ecdsa.pub**（ECDSA） **〜/.ssh/id_ed25519.pub**（Ed25519）或**〜/.ssh/id_rsa.pub**（RSA）在用户的主目录中。 然后，用户应该将公钥复制到远程机器上的主目录中的**〜/.ssh/authorized_keys**。 **authorized_keys**文件对应于传统的**〜/.rhosts**文件，每行有一个键，尽管行可以很长。 此后，用户可以登录而不提供密码。 公共密钥认证的变体以证书身份验证的形式提供：不使用一组公钥/私钥，使用签名证书。 这具有以下优点：可以使用单个可信赖的证书颁发机构来代替许多公钥/私钥。 有关详细信息，请参阅ssh-keygen的CERTIFICATES部分。 使用公钥或证书认证的最方便的方法可以是认证代理。 有关详细信息，请参阅ssh-agent和（可选）ssh_config中的AddKeysToAgent指令。 挑战响应认证的工作原理如下：服务器发送任意的“挑战”文本，并提示响应。 挑战响应认证的示例包括BSD认证（参见login.conf）和PAM（一些非OpenBSD系统）。 最后，如果其他身份验证方法失败，ssh将提示用户输入密码。 密码发送到远程主机进行检查; 然而，由于所有通信都被加密，所以在网络上侦听的人不能看到密码。 ssh会自动维护和检查包含所有主机所使用的标识的数据库。 主机密钥存储在用户主目录中的**〜/.ssh/known_hosts**中。 此外，文件**/etc/ssh/ssh_known_hosts**会自动检查已知主机。 任何新的主机都将自动添加到用户的文件中。 如果主机的识别发生变化，**ssh**会对此进行警告，并禁用密码身份验证，以防止服务器欺骗或中间人攻击，否则可能会用来规避加密。 **StrictHostKeyChecking**选项可用于控制对主机密钥未知或已更改的计算机的登录。 当用户的身份被服务器接受时，服务器可以在非交互会话中执行给定的命令，或者如果没有指定命令，则登录到机器中，并将用户作为交互式会话给出正常的外壳。 与远程命令或shell的所有通信将被自动加密。 如果请求了一个交互式会话，ssh默认情况下只会在客户端具有一个交互会话时请求伪终端（pty）。 标志**-T**和**-t**可用于覆盖此行为。 如果已经分配了伪终端，则用户可以使用下面指出的转义字符。 如果没有分配伪终端，会话是透明的，可以用于可靠地传输二进制数据。 在大多数系统上，将转义字符设置为“none”也将使会话透明，即使使用tty。 当远程机器上的命令或shell退出并且所有X11和TCP连接都已关闭时，会话终止。 ","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/:4:0","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Linux"],"content":"转义字符 当请求伪终端时，ssh通过使用转义字符支持多个功能。 单个波浪号字符可以以~~或通过除了下面描述的字符之外的字符跟随波浪号来发送。 转义字符必须始终按照换行符被解释为特殊的。 可以使用EscapeChar配置指令在命令行中使用**-e**选项来更改配置文件中的转义字符。 支持的转义（假设默认为`〜'）为： ~. 断开 ~^Z ssh背景 ~# 列出转发的连接。 ~\u0026 在等待转发连接/ X11会话终止时，注销时出现背景信息。 ~? 显示转义字符列表。 ~B 发送一个BREAK到远程系统（只有当对端支持它时才有用）。 ~C 打开命令行。 目前，这允许使用**-L**，**-R**和**-D**选项添加端口转发（见上文）。它还允许使用-**KL [bind_address:]port**取消现有端口转发，用于远程的**-KR [bind_address:]port**和用于动态端口转发的**-KD [bind_address:]port**。 **!command**允许用户在ssh_config中启用**PermitLocalCommand**选项时执行本地命令。 使用**-h**选项提供基本帮助。 ~R 请求重新连接连接（仅在对端支持时才有用）。 ~V 当错误被写入stderr时，减小详细程度（LogLevel）。 ~v 当错误被写入stderr时，增加详细程度（LogLevel）。 ","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/:5:0","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Linux"],"content":"TCP转发 可以在命令行或配置文件中指定通过安全通道转发任意TCP连接。 TCP转发的一个可能应用是与邮件服务器的安全连接; 另一个是通过防火墙。 在下面的例子中，我们将介绍加密IRC客户端和服务器之间的通信，即使IRC服务器不直接支持加密通信。 这样做如下：用户使用ssh连接到远程主机，指定用于将连接转发到远程服务器的端口。 之后，可以启动要在客户机上加密的服务，连接到同一本地端口，ssh将加密和转发连接。 以下示例从客户机隧道传输IRC会话”127.0.0.1”（localhost）到远程服务器”server.example.com”： $ ssh -f -L 1234:localhost:6667 server.example.com sleep 10 $ irc -c '#users' -p 1234 pinky 127.0.0.1 这个隧道连接到IRC服务器”server.example.com”，使用端口1234加入通道”#users”，昵称”pinky”。它不使用哪个端口，例如只要它大于1023（请记住，只有root可以在特权端口上打开套接字），并且不会与已在使用的任何端口冲突。 连接转发到远程服务器上的端口6667，因为这是IRC服务的标准端口。 指定**-f**选项背景**ssh**和远程命令”sleep 10”，以允许一段时间（在本例中为10秒）启动要被隧道传输的服务。 如果在指定的时间内没有连接，则ssh将退出。 ","date":"2017-04-24","objectID":"/2017/04/linux-command-record-ssh/:6:0","tags":["ssh"],"title":"Linux记录之ssh","uri":"/2017/04/linux-command-record-ssh/"},{"categories":["Java"],"content":"文章描述","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"第1章 分布式系统介绍 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/:1:0","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"1.1 初识分布式系统 1.1.1 分布式系统的定义 首先分布式系统一定是由多个节点组成的系统，一般来说一个节点就是我们的一台计算机；然后这些节点不是孤立的，而是互相连通的；最后，这些连通的节点上部署了我们的组建，并且相互之间的操作会有协同。 1.1.2 分布式系统的意义 下面三个方面 * 升级单机处理能力的性价比越来越低。 * 单机处理能力存在瓶颈。 * 出于稳定性和可用性的考虑。 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/:1:1","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"1.2 分布式系统的基础知识 1.2.1 组成计算机的5要素 冯 ∘ 诺依曼型计算机的5个组成部分： * 输入设备 * 输出设备 * 运算器 * 控制器 * 存储器——内存和外存 1.2.2 线程与进程的执行模式 一个进程可以有多个线程，一个线程只属于一个进程。 1.2.2.1 阿姆达尔定律 Amdahl’s law: S(N) = 1 / ((1 - P) + P / N) 其中，P指的是程序中可并行部分的程序在单核上执行时间的占比，N表示处理器的个数（总核心数）。S(N)是指程序在N个处理器（总核心数）相对在单个处理器（单核）中的速度提升比。 这个公式告诉我们，程序中可并行代码的比例决定你增加处理器（总核心数）所能带来的速度提升的上限，是否能达到这个上限，还取决于很多其它的因素。 1.2.2.2 互不通信的多线程模式 两个线程，没有交集，各自执行各自的任务和逻辑。 1.2.2.3 基于共享容器协同的多线程模式 有一个队列用于生产和消费，那么，这个队列就是多个线程会共享的一个容器或者是数据对象，多个线程会并发访问这个队列。 需要加锁控制并发。 1.2.2.4 通过事件协同的多线程模式 一个线程需要另一个线程的触发才能执行。 防止死锁。 1.2.2.5 多进程模式 多进程和多线程有比较多的相似之处，也有不同。不同的最大原因是，线程是属于进程的，一个进程内的多个线程共享了进程的内存空间；而多个进程之间的内存空间是独立的，因此多个进程间通过内存共享、交换数据的方式与多个线程间的方式就有所不同。此外，进程间的通信、协调，以及通过一些事件通知活着等待一些互斥锁的释放方面，也会与多线程不一样。 1.2.3 网络通信基础知识 在分布式系统中，组件分布在网络上的多个节点中，通过消息的传递来通信并且进行动作的协调。因此网络通信在分布式系统中非常重要。 1.2.3.1 OSI与TCP/IP网络模型 ISO的OSI网络模型 * Application Layer * Presentation Layer * Session Layer * Transport Layer * Network Layer * Data Link Layer * Physical Layer TCP/IP网络模型 * Application * Transport * Internetwork * Network Interface 1.2.3.2 网络IO实现方式 1.2.3.2.1 BIO方式 BIO即Blocking IO，采用阻塞的方式实现。也就是一个Socket套接字需要使用一个线程来进行处理。发生建立连接、读数据、写数据的操作时，都可能会阻塞。 1.2.3.2.2 NIO方式 NIO即Nonblocking IO，基于事件驱动思想，采用的是Reactor模式。 在NIO的方式下不是用单个线程去应对单个Socket套接字，而是统一通过Reactor对所有客户端的Socket套接字的事件做处理，然后派发到不同的线程中。 1.2.3.2.3 AIO方式 AIO即AsynchronousIO，就是异步IO。AIO采用Proactor模式。AIO与NIO的差别是，AIO在进行读写操作时，只需要调用相对应的read/write方法，并且需要传入CompletionHandler；在动作完成后，会调用CompletionHandler。 1.2.4 如何把应用从单机扩展到分布式 1.2.4.1 输入设备的变化 将分布式中的某个节点作为输入设备。 1.2.4.2 输出设备的变化 将分布式中的某个节点作为输出设备。 1.2.4.3 控制器的变化 单机系统中，控制器就是CPU中的控制器。在分布式系统中，负载均衡系统就算是一种控制器。 使用硬件负载均衡的请求调用 在集群中，这种方式对于发起请求的一方和处理请求的一方来说，都是透明的，可以称为透明代理。 使用LVS的请求调用 这种方式存在两个不足： * 会增加网络的开销，这个开销一方面指的是流量，另外一方面指的是延迟。 * 这个透明代理处于请求的必经路径上，如果代理出现问题，那么所有的请求都会受到影响。 采用名称服务的直连方式的请求调用 在请求发起方和请求处理方的直接连接外部，有一个“名称服务”的角色，它的作用主要有两个，一个是收集提供请求处理的服务器的地址信息；另外一个是提供这些地址信息给请求发起方。 采用规则服务器控制路由的请求直接调用 在请求发起的机器上，会有对规则进行处理从而进行请求处理服务机器选择的代码逻辑。这个方式与名称服务方式的不同在于，名称服务是通过跟请求处理的机器交互来获得这些机器的地址的，而规则服务器的方式中，规则服务器本身并不和请求处理的机器进行交互，只负责把规则提供给请求发起的机器。 Master + Worder的方式 存在一个Master节点来管理任务，由Master把任务分配给不同的Worker去进行处理。 1.2.4.4 运算器的变化 在单机系统中，运算器是具体的电子元件，而在分布式系统中，运算器是由多个节点来组成的。 总结起来，构成运算器的多个节点在控制器的配合下对外提供服务，构成了分布式系统中的运算器。 1.2.4.5 存储器的变化 方案与前面相同，依次是代理、名称服务、规则服务、Master-Worker服务。 1.2.5 分布式系统的难点 1.2.5.1 缺乏全局时钟 很多时候我们使用时钟，它可以区分两个动作的顺序，而不一定要知道准确的时间。这种情况需要交给一个单独的集群来处理。 1.2.5.2 面对故障独立性 在分布式系统中，整个系统的一部分有问题而其它部分正常是经常出现的情况，我们称之为故障独立性。 1.2.5.3 处理单点故障 在整个分布式系统中，如果某个角色或者功能只有某台单机在支撑，那么这个节点称为单点，其发生的故障称为单点故障，也是常说的SPoF(Single Point of Failure)。 一台数据库拆分到多台数据库后，出现故障的次数和总时间会比单台数据库的时候要多。也就是说，我们增加了故障出现的次数和时间，降低了故障的影响面。 1.2.5.4 事物的挑战 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-01/:1:2","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-01","uri":"/2016/11/java-middleware-note-01/"},{"categories":["Java"],"content":"文章描述","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-02/","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-02","uri":"/2016/11/java-middleware-note-02/"},{"categories":["Java"],"content":"第2章 大型网站及其架构演进过程 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-02/:1:0","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-02","uri":"/2016/11/java-middleware-note-02/"},{"categories":["Java"],"content":"2.1 什么是大型网站 要满足一个网站是大型网站，需要很多因素。大型网站除了要支撑海量的数据和非常高的并发访问量，本身业务和系统的复杂度也是考察的方面。 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-02/:1:1","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-02","uri":"/2016/11/java-middleware-note-02/"},{"categories":["Java"],"content":"2.2 大型网站的架构演进 2.2.1 用Java技术和单机来构建的网站 选择一个开源的Server作为容器 直接使用JSP/Servlet等技术或者使用一些开源框架来构建应用 选择一个数据库管理系统来存储数据 通过JDBC进行数据库的连接和操作 2.2.2 从一个单机的交易网站说起 作为一个交易网站，需要具备的最基本功能： 用户 用户注册 用户管理 信息维护 …… 商品 商品展示 商品管理 …… 交易 创建交易 交易管理 …… 2.2.3 单机负载告警，数据库与应用分离 网站访问量增大，服务器的负载持续升高。 解决方案：应用与数据库从一台机器分到两台机器。 2.2.4 应用服务器负载告警，如何让应用服务器走向集群 应用服务器压力变大，将应用服务器从一台变成两台，但是有两个问题需要解决： 最终用户对两个应用服务器访问的选择问题 Session的问题 2.2.4.1 引入负载均衡设备 负载均衡来解决应用服务器访问的选择问题。 2.2.4.2 解决应用服务器变为集群后的Session问题 2.2.4.2.1 Session Sticky Web服务器变成多台以后，如果保证同一个会话的请求都在同一个Web服务器上处理，那么对这个会话的个体来说，与之前单机的情况是一样的。如果要做到这样，就需要负载均衡器能够根据每次请求的绘画标识来进行请求转发，这称为Session Sticky方式。 不过也带来了如下几个问题： 如果有一台Web服务器宕机或者重启，那么这台机器上的会话数据就会丢失。 会话标识是应用层的信息，那么负载均衡器要将同一个会话的请求都保存到同一个Web服务器上的话，就需要进行应用层（第7层）的解析，这个开销比第4层的交换要大。 负载均衡器变为了一个有状态的节点，要将会话保存到具体Web服务器的映射。和无状态的节点相比，内存消耗会更大，容灾方面会更麻烦。 2.2.4.2.2 Session Replication 在Session Replication方式中，不再要求负载均衡器来保证同一个会话的多次请求必须到同一个Web服务器上了。而我们的Web服务器之间则增加了会话数据的同步。通过同步就保证了不同Web服务器之间的Session数据的一致。 不过这个方案本身也有问题： 同步Session数据造成了网络带宽的开销。只要Session数据有变化，就需要将数据同步到所有其它机器上，机器数越多，同步带来的网络带宽开销就越大。 每台Web服务器都要保存所有的Session数据，如果整个集群的Session数很多（很多人在同时访问网站）的话，每台机器用于保存Session数据的内容占用会很严重。 这个方案不适合集群机器数多的场景，如果只有几台机器，用这个方案是可以的。 2.2.4.2.3 Session数据集中存储 将Session数据放在了一个集中存储的地方，统一从这里读写。 该方案存在的问题： 读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在延时和不稳定性，不过我们的通信基本都是发生在内网，问题不大。 如果集中存储Session的机器或者集群有问题，就会影响我们的应用。 相对于Session Replication，当Web服务器数量比较大、Session数比较多的时候，这个集中存储方案的优势是非常明显的。 2.2.4.2.4 Cookie Based 通过Cookie来传递Session数据。 该方案存在的问题： Cookie长度的限制。 安全性。 带宽消耗。 性能影响。 2.2.5 数据读写压力变大，读写分离吧 2.2.5.1 采用数据库作为读库 对于大型网站来说，有不少业务是读多写少的，这个状况也会直接反应到数据库上。所以在结构上增加了一个读库，这个库不承担写的工作，只提供读服务。 这个结构的变化会到来两个问题： 数据复制问题 应用对于数据源的选择问题 2.2.5.2 搜索引擎其实是一个读库 搜索引擎的技术解决了站内搜索时某些场景下读的问题，提供了更好的查询效率。并且我们看到的站内搜索的结构和使用读库是非常类似的，我们可以把搜索引擎当成一个读库。 2.2.5.3 加速数据读取的利器——缓存 2.2.5.3.1 数据缓存 “热”数据缓存，即应用访问缓存，如果数据不存在，则从数据库读出数据后放入缓存； 全数据缓存，在数据变化时能够及时更新缓存中的数据，不会造成读取失败。 2.2.5.3.2 页面缓存 Nginx Tomcat 2.2.6 弥补关系型数据库的不足，引入分布式存储系统 常见的分布式存储系统有分布式文件系统、分布式Key—Value系统和分布式数据库。 分布式存储系统自身起到了存储的作用，也就是提供数据的读写支持。 分布式存储系统通过集群提供了一个高容量、高并发访问、数据冗余容灾的支持。 2.2.7 读写分离后，数据库又遇到瓶颈 2.2.7.1 专库专用，数据垂直拆分 垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。 带来的问题： 应用需要配置多个数据源，不过带来了数据库连接池的隔离； 事物处理，一种办法是分布式事务，性能低，另一种办法是去掉事务或者不去追求强事务支持。 2.2.7.2 垂直拆分后的单机遇到瓶颈，数据水平拆分 数据水平拆分就是把同一个表的数据拆到两个数据库中。 带来的影响： 应用系统需要解决SQL路由的问题； 主键的处理 一些查询需要从两个数据库中取数据，如果数据了太大而需要分页，就会比较难处理。 2.2.8 数据库问题解决后，应用面对的新挑战 2.2.8.1 拆分应用 根据业务的特性把应用拆开。 影响： 这样拆分后在不同系统中会有一些相似的代码。如果能够保证这部分代码的一致以及如何对其复用是需要解决的问题； 按这样的方式拆分出来的新系统之间一般没有直接的相互调用； 新拆出来的应用可能会连接同样的数据库。 2.2.8.2 走服务化的路 把应用分为了三层： 处于最上端的是Web系统，用于完成不同的业务功能； 处于中间的一些服务中心，不同的服务中心提供不同的业务服务； 处于下层的则是业务的数据库。 与之前相比有几个很重要的变化： 业务功能之间的访问不仅是单机内部的方法调用，还引入了远程的服务调用； 共享的代码不再是散落在不同的应用中，这些实现被放在了各个服务中心； 把与数据库的交互工作放到了服务中心，让前端的Web应用更加注重与浏览器交互的工作； 通过服务化，能够更好的保持稳定性。 2.2.9 初识消息中间件 面向消息的系统是在分布式系统中完成消息的发送和接受不了的基础软件。 ","date":"2016-11-08","objectID":"/2016/11/java-middleware-note-02/:1:2","tags":["Middleware"],"title":"大型网站系统与Java中间件实践-笔记-02","uri":"/2016/11/java-middleware-note-02/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"介绍 ownCloud是一种私人文件系统，在公司内部搭建方便上传、下载以及分享文件。 产品可以上传需求文件，测试可以上传测试用例。 参考地址：http://tecadmin.net/install-owncloud-on-centos/ ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:1:0","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"安装 ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:0","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第一步 添加仓库的yum源 rpm -Uvh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:1","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第二步 安装LAMP环境 安装Apache，有的是系统默认安装 yum —enablerepo=remi,epel install httpd 安装MySQL yum —enablerepo=remi,epel install mysql-server service mysqld start mysql_secure_installation 安装PHP环境 yum --enablerepo=remi,epel install php php-mysql php-mcrypt php-curl php-gd php-xml php-mbstring ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:2","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第三步 下载owncloud源码 wget https://download.owncloud.org/community/owncloud-9.1.1.tar.bz2 tar -xjf owncloud-9.1.1.tar.bz2 -C /var/www/html/ chown -R apache.apache /var/www/html/owncloud chmod -R 755 owncloud 添加链接 我在按照原文安装后，浏览器访问404，查看httpd的错误日志才发现，提示/var/wwwnone/html/owncloud不存在，所以需要在这个位置添加一个链接。 ln -s /var/www/html/owncloud/ /var/wwwnone/html/owncloud 重启httpd服务 service httpd restart ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:3","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第四步 创建数据库和用户 mysql -uroot -p mysql\u003e CREATE DATABASE owncloud; mysql\u003e GRANT ALL ON owncloud.* TO 'owncloud'@'localhost' IDENTIFIED BY '_password_'; mysql\u003e FLUSH PRIVILEGES; mysql\u003e quit ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:4","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"第五步 开启浏览器访问安装 在浏览器中输入http://ip/owncloud，创建admin用户，填写数据库连接地址，点击完成安装即可。 ","date":"2016-11-07","objectID":"/2016/11/install-owncloud9-on-centos6/:2:5","tags":["OwnCloud"],"title":"在CentOS6服务器上安装ownCloud9","uri":"/2016/11/install-owncloud9-on-centos6/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-10-28","objectID":"/2016/10/vim-records/","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["DevTools"],"content":"VIM 的操作记录 ","date":"2016-10-28","objectID":"/2016/10/vim-records/:1:0","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["DevTools"],"content":"初始化过程 配置文件载入过程： /etc/vimrc $HOME/.vim/,$HOME/.vimrc $VIMRUNTIME/.vim/,$VIMRUNTIME/.vimrc $HOME/.vim/after/ 通过运行vim -V可查看整个初始化过程。 ","date":"2016-10-28","objectID":"/2016/10/vim-records/:1:1","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["DevTools"],"content":"操作快捷键 普通模式 h 光标左移一位 l 光标右移一位 j 光标下移一位 k 光标上移一位 H 光标移动到当前屏幕的第一行 M 光标移动到当前屏幕的中间 L 光标移动到当前屏幕的最后一行 zt 光标所在的行移动到屏幕的最上方 zz 光标所在的行移动到屏幕的中间 zb 光标所在的行移动到屏幕的最下方 插入模式 可视模式 替换模式 命令行模式 ","date":"2016-10-28","objectID":"/2016/10/vim-records/:1:2","tags":["VIM"],"title":"VIM操作记录","uri":"/2016/10/vim-records/"},{"categories":["Python"],"content":"文章描述","date":"2016-09-28","objectID":"/2016/09/python-library-collection/","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"Python 科学计算第三方库 ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:0","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"matplotlib 绘制一些高质量的的数学二维图形。 pip install --user matplotlib 依赖安装的其它库 pyparsing python-dateutil cycler numpy pytz six ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:1","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"scipy 基于Python的matlab实现，旨在实现matlab的所有功能。 pip install --user scipy ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:2","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Python"],"content":"numpy 基于Python的科学计算第三方库，提供了矩阵，线性代数，傅立叶变换等等的解决方案。 pip install --user numpy ","date":"2016-09-28","objectID":"/2016/09/python-library-collection/:1:3","tags":["Python"],"title":"Python第三方库收集","uri":"/2016/09/python-library-collection/"},{"categories":["Java"],"content":"Gradle使用记录－－来自官网 ","date":"2016-09-21","objectID":"/2016/09/java-gradle-records/:1:0","tags":["Gradle"],"title":"Gradle使用记录","uri":"/2016/09/java-gradle-records/"},{"categories":["Java"],"content":"安装 1. 先决条件 Gradle需要安装JDK或者JRE，版本为7及以上(可以通过java -version检查)。 配置JAVA_HOME环境变量。 2. 下载 http://www.gradle.org/downloads 3. 解压 4. 配置环境变量 配置GRADLE_HOME，并且将GRADLE_HOME/bin加入到PATH中。 5. 运行并测试安装是否成功 gradle -v 6. 配置JVM参数 可以配置GRADLE_OPTS或者JAVA_OPTS，或者两个都可以。 这些可以配置到环境变量中，也可以配置到gradle或者gradlew之前。 ","date":"2016-09-21","objectID":"/2016/09/java-gradle-records/:1:1","tags":["Gradle"],"title":"Gradle使用记录","uri":"/2016/09/java-gradle-records/"},{"categories":["Java"],"content":"使用Gradle命令行 1. 执行多个任务 创建文件build.gradle task compile \u003c\u003c { println 'compiling source' } task compileTest(dependsOn: compile) \u003c\u003c { println 'compiling unit tests' } task test(dependsOn: [compile, compileTest]) \u003c\u003c { println 'running unit tests' } task dist(dependsOn: [compile, test]) \u003c\u003c { println 'building the distribution' } 保存退出后，执行命令 gradle dist test 2. 拒绝执行任务 使用-x参数拒绝某个任务执行。 gradle dist -x test 你会看到不止test没有执行，test依赖的compileTest也没有执行。 3. 某个任务失败也继续执行 如果使用了--continue参数，无论哪个任务失败，其余的任务都会执行。 4. 任务缩略名 如果你不知道某个任务的全称，只知道简称也可以，不过简称必须是唯一的。 gradle di gradle dist 上面两条命令会输出相同结果。 如果要执行compileTest这个任务，下面的命令都可以 gradle compileTest gradle compTest gradle cT 5. 指定执行的构建文件 当执行gradle命令时，看起来都是在当前路径构建。你可以使用-b参数执行构建文件。如果使用-b参数，则settings.gradle无效。 当多个项目构建时，你可以使用-p参数代替-b参数。 gradle -q -p subdir hello ⚠️目前此命令我没有执行成功，还没有查明原因！！！ 6. 专注任务执行 没看懂 7. 获得构建信息 7.1 列出所选子项目的名单 gradle -q projects 7.2 列出所选主任务的名单 gradle -q tasks 可以加上--all参数获得列出的任务里的更多信息。 7.3 显示任务使用详细信息 gradle help --task someTask 7.4 列出项目的依赖信息 gradle -q dependencies [subpro:dependencies] 由于依赖报告太多，可以使用--configuration参数来限制报告。 gradle -q api:dependencies --configuration testCompile 7.5 列出项目构建脚本的依赖 gradle buildEnvironment ","date":"2016-09-21","objectID":"/2016/09/java-gradle-records/:1:2","tags":["Gradle"],"title":"Gradle使用记录","uri":"/2016/09/java-gradle-records/"},{"categories":["Java"],"content":"文章描述","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"Spring源码深度解析－－构建环境 本文是根据《Spring源码深度解析》（编著：郝佳）这本书记录的学习笔记。 ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:0","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"必备环境变量 Git Java 必须是JDK8update20及更新 必须配置JAVA_HOME到jdk1.8.0 ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:1","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"下载源码 git clone https://github.com/spring-projects/spring-framework.git ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:2","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Java"],"content":"导入到IDEA 需要先执行一条命令 ./gradlew cleanIdea :spring-oxm:compileTestJava 接下来就是漫长的等待。 根据打印的日志，以及读取gradlew命令文件可知，这是先去下载最新的gradle压缩包了，虽然我已经提前下载并且配置好了。 下载完压缩包，然后是下载需要的jar包，再次漫长的等待后会看到SUCCESS。 接下来执行命令 ./gradlew install 再次漫长等待。。。 成功后再次输入命令 ./gradlew build 我的心，在等待，永远在等待。。。 终于结束了。 使用IDEA的Import Project导入项目，会提示gradle build，没关系，这次会快很多，因为先前已经把该下载的jar包都下载了。 搞定。 ","date":"2016-09-19","objectID":"/2016/09/spring-source-study-1/:1:3","tags":["Spring"],"title":"Spring源码深度解析－－学习笔记1","uri":"/2016/09/spring-source-study-1/"},{"categories":["Database"],"content":"先当草稿记着，之后要分开记录","date":"2016-09-19","objectID":"/2016/09/sql-categories/","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"SQL分类－－记录来自维基百科 结构化查询语言(英语：Structural Query Language，缩写：SQL) ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:0","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据查询语言 英语：Data Query Language，缩写：DQL 负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。 语法结构 SELECT ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:1","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据定义语言 英语：Data Definition Language，缩写：DDL 负责数据结构定义与数据库对象定义的语言。 语法结构 CREATE ALTER DROP RENAME TRUNCATE ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:2","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据操纵语言 英语：Data Manipulation Language，缩写：DML 负责对数据库对象运行数据访问工作的指令集。 语法结构 INSERT UPDATE DELETE ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:3","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Database"],"content":"数据控制语言 英语：Data Control Language，缩写：DCL 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据看对象的控制权。 语法结构 GRANT REVOKE ","date":"2016-09-19","objectID":"/2016/09/sql-categories/:1:4","tags":["SQL"],"title":"SQL分类－－DQL、DDL、DML、DCL","uri":"/2016/09/sql-categories/"},{"categories":["Java"],"content":"背景 此篇只为导航，感谢博客园中的java-my-lift的详细讲解。 每天学一篇设计模式，记录到导航页中，不做转载。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:0","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"1. 简单工厂模式 简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 例子：登陆－－域名登陆，口令登陆 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:1","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"2. 工厂方法模式 工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。 工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 例子：导出文件－－导出Excel，导出HTML，导出PDF ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:2","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"3. 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 例子：装机工程师组装电脑 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:3","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"4. 单例模式 作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 4-1. 饿汉式单例模式 空间换时间 类装载的时候就创建实例 public class EagerSingleton { private static EagerSingleton instance = new EagerSingleton(); /** * 私有默认构造子 */ private EagerSingleton(){} /** * 静态工厂方法 */ public static EagerSingleton getInstance(){ return instance; } } 4-2. 懒汉式单例模式 时间换空间 调用时再创建实例 public class LazySingleton { private static LazySingleton instance = null; /** * 私有默认构造子 */ private LazySingleton(){} /** * 静态工厂方法 */ public static synchronized LazySingleton getInstance(){ if(instance == null){ instance = new LazySingleton(); } return instance; } } 4-3. 双重检查加锁 volatile关键字 线程安全 运行效率不高，不建议采用 public class Singleton { private volatile static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ //先检查实例是否存在，如果不存在才进入下面的同步块 if(instance == null){ //同步块，线程安全的创建实例 synchronized (Singleton.class) { //再次检查实例是否存在，如果不存在才真正的创建实例 if(instance == null){ instance = new Singleton(); } } } return instance; } } 4-4. 类级内部类 延迟加载 线程安全 public class Singleton { private Singleton(){} /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 * 没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。 */ private static class SingletonHolder{ /** * 静态初始化器，由JVM来保证线程安全 */ private static Singleton instance = new Singleton(); } public static Singleton getInstance(){ return SingletonHolder.instance; } } 4-5. 枚举单例 简洁、高效、安全 public enum Singleton { /** * 定义一个枚举的元素，它就代表了Singleton的一个实例。 */ uniqueInstance; /** * 单例可以有自己的操作 */ public void singletonOperation(){ //功能处理 } } ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:4","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"5. 建造模式 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 例子：订阅杂志，发送欢迎邮件，取消订阅，发送欢送邮件 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:5","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"6. 原型模式 原型模式术语对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意。 例子：美猴王分身 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:6","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"7. 适配器模式 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够一起工作。 例子：三相插头转到两相插头的转换器 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:7","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"8. 合成模式 合成模式属于对象的机构模式，有时又叫做“部分－－－－整体”模式。合成模式将对象组装到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:8","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"9. 装饰模式 装饰模式又名包装（Wrapper）模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 例子：齐天大圣七十二变，JAVA I/O库的基本模式 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:9","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"10. 代理模式 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:10","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"11. 享元模式 享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:11","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"12. 门面模式 门面模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 例子：医院的各个部门由接待员负责。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:12","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"13. 桥梁模式 桥梁模式是对象的结构模式。又称为柄体(Handle and Body)模式或接口(interface)模式。桥梁模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。 例子：发送消息－－普通消息，加急消息，特急消息 JDBC驱动器就是一个典型的桥梁模式。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:13","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"14. 不变模式 一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变模式。 不变模式只涉及到一个类。一个类的内部状态创建后，在整个生命周期都不会发生变化时，这样的类称作不变类。这种使用不变类的做法叫做不变模式。不变模式有两种形式：一种是弱不变模式，另一种是强不变模式。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:14","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"15. 策略模式 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生改变。 例子：购物网站，针对不同级别会员打折。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:15","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"16. 模板方法模式 模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模版方法模式的用意。 例子：存款利息－－货币市场和定期存款 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:16","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"17. 观察者模式 观察者模式是对象的行为模式，又叫发布－订阅(Publish/Subscribe)模式、模型－视图(Model/View)模式、源－监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:17","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"18. 迭代子模式 迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象(internal representation)。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:18","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"19. 责任链模式 责任链模式时一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 例子：击鼓传花 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:19","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"20. 命令模式 命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队活着记录请求日志，可以提供命令的撤销和恢复功能。 例子：录音机 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:20","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"21. 备忘录模式 备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。 备忘录对象是一个用来存储另外一个对象内部状态的快找的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。 白箱 黑箱 多重检查点 自述历史 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:21","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"22. 状态模式 状态模式，又称状态对象模式（Pattern of Objects for States），状态模式时对象的行为模式。 状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。 例子：在线投票系统－－正常投票、重复投票、恶意刷屏、黑名单 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:22","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"23. 访问者模式 访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:23","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"24. 解释器模式 解释器是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:24","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Java"],"content":"25. 调停者模式 调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其它的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。 ","date":"2016-09-02","objectID":"/2016/09/java-design-patterns/:0:25","tags":["设计模式"],"title":"JAVA与模式－－设计模式","uri":"/2016/09/java-design-patterns/"},{"categories":["Python"],"content":"文章描述","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"学习自廖雪峰的官方网站–Python教程 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:0:0","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"Python的高级特性 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:0","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"切片 创建一个0-99的数列 \u003e\u003e\u003e L = list(range(100)) \u003e\u003e\u003e L [0, 1, 2, 3, ..., 99] 前10个数： \u003e\u003e\u003e L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： \u003e\u003e\u003e L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： \u003e\u003e\u003e L[10:20] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： \u003e\u003e\u003e L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： \u003e\u003e\u003e L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 原样复制list \u003e\u003e\u003e L[:] [0, 1, 2, 3, ..., 99] 倒转list \u003e\u003e\u003e L[::-1] [99, 98, 97, 96, ..., 0] tuple切片仍是tuple： \u003e\u003e\u003e (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串也可以当作list来切片 \u003e\u003e\u003e 'ABCDEFG'[:3] 'ABC' \u003e\u003e\u003e 'ABCDEFG'[::2] 'ACEG' ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:1","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"迭代 通过for ... in循环来遍历list或tuple，这种便利称为迭代(iteration)。 迭代dict 默认dict迭代的是key \u003e\u003e\u003e d = {'a': 1, 'b': 2, 'c': 3} \u003e\u003e\u003e for key in d: ... print(key) ... a c b 迭代dict的value \u003e\u003e\u003e for value in d.values(): ... print(value) ... 1 2 3 同时迭代key和value \u003e\u003e\u003e for k, v in d.items(): ... print(k, v) ... b 2 c 3 a 1 判断一个对象是否可迭代 通过collections模块的Iterable类型判断： \u003e\u003e\u003e from collections import Iterable \u003e\u003e\u003e isinstance('abc', Iterable) # str是可迭代对象 True \u003e\u003e\u003e isinstance([1, 2, 3], Iterable) # list是可迭代对象 True \u003e\u003e\u003e isinstance(123, Iterable) # 整数不是可迭代对象 False list实现下标循环 使用Python内置的enumerate函数实现 \u003e\u003e\u003e for i, v in enumerate(['A', 'B', 'C']): ... print(i, v) ... 0 A 1 B 2 C ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:2","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"列表生成式 简单方便的生成list \u003e\u003e\u003e [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] \u003e\u003e\u003e [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] \u003e\u003e\u003e [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] \u003e\u003e\u003e d = {'x': 'A', 'y': 'B', 'z': 'C' } \u003e\u003e\u003e [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] \u003e\u003e\u003e L = ['Hello', 'World', 'IBM', 'Apple'] \u003e\u003e\u003e [s.lower() for s in L] ['hello', 'world', 'ibm', 'apple'] ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:3","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"生成器 把列表生成式的[]改成()就可以创建一个生成器g 通过next(g)打印出来 创建一个斐波拉契数列的生成器 def fib(max): n, a, b = 0, 0, 1 while n \u003c max: yield b a, b = b, a + b n += 1 return 'done' ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:4","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"迭代器 \u003e\u003e\u003e from collections import Iterator \u003e\u003e\u003e isinstance((x for x in range(10)), Iterator) True \u003e\u003e\u003e isinstance([], Iterator) False \u003e\u003e\u003e isinstance({}, Iterator) False \u003e\u003e\u003e isinstance('abc', Iterator) False 凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 from collections import Iterator \u003e\u003e\u003e isinstance(iter([]), Iterator) True \u003e\u003e\u003e isinstance(iter('abc'), Iterator) True ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:5","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"函数式编程 高阶函数 map/reduce map函数：把第一个参数(函数)，作用在第二个参数(Iterable)的每个元素上，并把结果作为新的Iterator返回。 例子: \u003e\u003e\u003e list(map(str, [1, 2, 3, 4, 5, 6, , 7, 8, 9])) ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce函数：第一个参数是函数，第二个参数是序列，函数依次作用于序列的每一个元素，并把结果作用于下一个元素 例子： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) filter 过滤序列。第一个参数是函数，第二个参数是序列，函数依次作用于序列的每一个元素，然后根据返回值True还是False决定保留还是丢弃该元素。 又是惰性的。 def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] sorted sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。 \u003e\u003e\u003e sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] 返回函数 一个函数返回另一个函数，不立即执行，调用时执行。 匿名函数 lambda表达式。 f = lambda x : x * x 装饰器 动态增加函数的功能。 import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s%s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 偏函数 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 \u003e\u003e\u003e import functools \u003e\u003e\u003e int2 = functools.partial(int, base=2) \u003e\u003e\u003e int2('1000000') 64 \u003e\u003e\u003e int2('1010101') 85 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:6","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"面向对象编程 访问限制 定义私有变量，需要在变量前加上两个下划线__，通过get方法获取，或者通过set方法赋值。 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量 强烈不建议这么干，不同版本的Python解释器可能会改成不同的变量名。 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 获取对象信息 type() \u003e\u003e\u003e import types \u003e\u003e\u003e def fn(): ... pass ... \u003e\u003e\u003e type(fn)==types.FunctionType True \u003e\u003e\u003e type(abs)==types.BuiltinFunctionType True \u003e\u003e\u003e type(lambda x: x)==types.LambdaType True \u003e\u003e\u003e type((x for x in range(10)))==types.GeneratorType True isinstance() 判断class的继承关系 也能替代type()判断基本类型 还可以判断一个变量是否是某些类型中的一种 \u003e\u003e\u003e isinstance([1, 2, 3], (list, tuple)) True \u003e\u003e\u003e isinstance((1, 2, 3), (list, tuple)) True dir() 如果要获取一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list. 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:7","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"面向对象高级编程 使用__slots__ 正常可以动态绑定实例的属性和方法，如果在实例中定义一个特殊的__slots__变量，则可以限制该class实例能添加的属性。 使用_slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用。 使用@property Python内置的@property装饰器就是负责把一个方法变成属性调用。 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value \u003c 0 or value \u003e 100: raise ValueError('score must between 0 ~ 100!') self._score = value 如果只定义了get方法，没有定义set方法，就是只读属性 定制类 需要特殊变量 __slots__ __len__ __str__ __repr__ __iter__ __next__ __getitem__ __getattr__ __call__ 使用元类 __metaclass__ 理解难点，找到了一个详细讲解的文章 深刻理解Python中的元类(metaclass) 此文章翻译自stackoverflow的一个神回复 what-is-a-metaclass-in-python ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:8","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"错误、调试、和测试 错误处理 捕获异常并处理 try...except...finally... 主动抛出异常 raise 调试 断言 断言返回False的，则抛出AssertionError assert n != 0, 'n is zero!' 启动Python解释器时可以用-0参数来关闭assert python3 -0 err.py logging pdb 让程序以单步方式运行 以参数-m pdb启动 输入命令n可以单步执行代码 输入命令p 变量名来查看变量 输入命令q结束调试，退出程序 也可以设置断点 需要先import pdb 在需要断点的地方放置pdb.set_trace() ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:9","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"IO编程 StringIO和BytesIO 操作文件和目录 OS模块 \u003e\u003e\u003e import os \u003e\u003e\u003e os.name # 操作系统类型 \u003e\u003e\u003e os.uname() # 详细的系统信息 \u003e\u003e\u003e os.environ() # 系统环境变量 \u003e\u003e\u003e os.path.abspath('.') # 当前目录绝对路径 \u003e\u003e\u003e os.path.join('/Users/Bruce', 'testdir') # 拼接路径 \u003e\u003e\u003e os.mkdir('/Users/Bruce/testdir') # 创建目录 \u003e\u003e\u003e os.rmdir('/Users/Bruce/testdir') # 删除目录 \u003e\u003e\u003e os.path.split('/Users/Bruce/testdir/file.txt') ('/Users/Bruce/testdir', 'file.txt') \u003e\u003e\u003e os.rename('test.txt', 'test.py') # 对文件重命名 \u003e\u003e\u003e os.remove('text'.py') # 删除文件 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:10","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"常用内建模块 datetime collections namedtuple depue defaultdict OrderedDict Counter base64 hashlib itertools count() cycle() repeat() takewhile() chain() groupby() XML DOM SAX HTMLParser urllib ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:11","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"常用第三方模块 PIL PIL:Python Imaging Library，强大的图片处理模块 Pillow，在PIL的基础上创建的兼容的版本 ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:12","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"异步IO 协程 没有理解，重点看一下。 asyncio async/await aiohttp ","date":"2016-09-01","objectID":"/2016/09/python-commands-records-01/:1:13","tags":["Python"],"title":"Python使用记录-学习笔记-01","uri":"/2016/09/python-commands-records-01/"},{"categories":["Python"],"content":"文章描述","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"pip基础命令记录–来源自官方文档 ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:0","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"在线安装第三方库 pip install SomePackage ＃ 最新版本 pip install SomePackage==1.0.4 # 指定版本 pip install SomePackage\u003e=1.0.4 # 最低限度版本 同时会安装依赖的其他第三方库 ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:1","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"需要安装的列表文件 pip install -r requirements.txt ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:2","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"导出已安装的第三方库列表 pip freeze \u003e ./requirements.txt ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:3","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"统一将第三方库安装到用户目录下 pip install --user SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:4","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"移除第三方库 pip uninstall SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:5","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看当前安装的第三方库 pip list ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:6","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查询需要升级的库 pip list --outdated ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:7","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"升级库 pip install --upgrade SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:8","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看库的详细信息 pip show SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:9","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"查看库的安装信息 pip show --files SomePackage ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:10","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["Python"],"content":"在线查找第三方库 pip search \"query\" ","date":"2016-08-31","objectID":"/2016/08/python-pip-basics/:1:11","tags":["Python"],"title":"Python使用记录-pip基础命令","uri":"/2016/08/python-pip-basics/"},{"categories":["DevTools","Python"],"content":"文章描述","date":"2016-08-24","objectID":"/2016/08/python-pyenv/","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"pyenv的使用记录 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:0","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"pyenv的仓库地址 https://github.com/yyuu/pyenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:1","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配合pyenv-virtualenv创建虚拟环境 https://github.com/yyuu/pyenv-virtualenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:2","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装pyenv brew install pyenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:3","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配置pyenv 配置工作目录 export PYENV_ROOT=/usr/local/var/pyenv 添加环境变量 if which pyenv \u003e /dev/null; then eval \"$(pyenv init -)\"; fi ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:4","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装pyenv-virtualenv brew install pyenv-virtualenv ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:5","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"配置pyenv-virtualenv 添加环境变量 if which pyenv-virtualenv-init \u003e /dev/null; then eval \"$(pyenv virtualenv-init -)\"; fi ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:6","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"重新加载SHELL环境，使环境变量生效 exec $SHELL ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:7","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"查看pyenv命令 pyenv commands ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:8","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"查看所有可安装Python版本 pyenv install --list ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:9","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"安装指定版本 pyenv install 2.7.12 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:10","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"本地指定使用已安装的版本 pyenv local 2.7.12 执行👆命令后，会在当前目录生成一个.python-version文件，用于指定当前目录中所使用的python版本。 如果当前目录没有.python-version文件，则会向上级目录查找，当前目录所使用的python版本，与上级目录指定的版本相同。 如果直到根目录都没有找到.python-version文件，则使用global设置的版本 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:11","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools","Python"],"content":"指定全局版本 pyenv global system system为系统默认python版本，非pyenv安装版本。 ","date":"2016-08-24","objectID":"/2016/08/python-pyenv/:1:12","tags":["Python"],"title":"Python使用记录-版本控制pyenv","uri":"/2016/08/python-pyenv/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-08-19","objectID":"/2016/08/git-tools/","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"Git命令使用记录－来源自官方文档 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:0:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"选择修订版本 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"简短的 SHA-1 查看每次提交简短的SHA-1值 git log --abbrev-commit --pretty=oneline 假设某个提交是1c002dd....，如果你想git show这个提交，下面三个命令是等价的（假设简短的版本没有歧义） git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b git show 1c002dd4b536e7479f git show 1c002dd ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"分支引用 如果想查看某个分支的最后一次提交信息，可以使用rev-parse探测出该分支的最后一次SHA-1值 git rev-parse \u003cbranchName\u003e 然后再git show打印出的SHA-1值 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"引用日志 git reflog 如果想查看仓库中HEAD在五次前的所指向的提交 git show HEAD@{5} 如果想查看master分支在昨天的时候指向了哪个提交 git show master@{yesterday} 引用日志只存在于本地仓库，如果查询的时间早于本地最早操作时间，则会显示第一次操作记录 可以运行git log -g来查看类似于git log输出格式的引用日志信息 git log -g master ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:3","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"祖先引用 查看HEAD的上一个提交，也就是“HEAD的父提交”，下面两个命令等价 git show HEAD^ git show HEAD~ 查看HEAD的第二父提交 git show HEAD^2 查看HEAD的第一父提交的第一父提交，下面两个命令等价 git show HEAD^^ git show HEAD~2 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:4","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"提交区间 双点 查看experiment分支中还有哪些提交尚未被合并入master分支 git log master..experiment 查看master分支中存在，而experiment分支中不存在的提交，下面三个命令等价 git log experiment..master git log ^experiment master git log master --not experiment 如果在..的某一边留空，则默认为HEAD 多点 查看所有被refA或refB包含的但是不被refC包含的提交，下面两个命令等价 git log refA refB ^refC git log refA refB --not refC 三点 查看master或者experiment中包含的但不是两者共有的提交 git log master...experiment 如果加上参数--left-right，会显示每个提交到底处于哪一侧的分支 git log --left-right master...experiment ","date":"2016-08-19","objectID":"/2016/08/git-tools/:1:5","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"交互式暂存 如果运行git add时使用-i或者--interactive选项，Git将会进入交互式终端模式 git add -i git add --interactive ","date":"2016-08-19","objectID":"/2016/08/git-tools/:2:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"储藏与清理 如果想要切换分支，但是不想提交之前修改的文件，这时需要用到储藏 git stash git stash save 这时就可以轻易的切换分支并在其他地方工作，如果想要查看储藏 git stash list 如果想要重新应用储藏，执行👇命令，如果不指定一个储藏，则默认最近一个 git stash apply git stash apply stash@{2} 重新应用后，之前暂存的文件并没有重新暂存，这时需要--index选项 git stash apply --index 重新应用后，堆栈上的储藏并不会删除，可以使用删除命令 git stash drop stash@{2} 如果想要将储藏重新应用后立即从栈上删除，可以使用👇的命令 git stash pop 如果不想储藏已暂存的文件，需要--keep-index选项 git stash save --keep-index 如果想储藏未跟踪文件，需要--include-untracked或-u选项 git stash save -u 如果指定了--patch标记，Git会交互式的提示储藏 git stash --patch ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"从储藏创建一个分支 如果重新应用储藏时，可能会有冲突，这时可能会想创建一个新分支，并在新分支上重新应用储藏 git stash branch \u003cbranchName\u003e ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"清理工作目录 移除所有未被忽略并且未被追踪的文件，非常危险！ git clean 更安全一些的命令，将所有文件储藏 git stash --all git clean的一些选项 查看git clean将会做什么，-n git clean -n 移除工作目录中所有未追踪的文件以及空的子目录，-d git clean -n -d 强制移除，确定移除，-f git clean -n -d -f 移除.gitignore文件忽略的文件类型，-x git clean -n -d -x -f 以交互模式运行clean命令，-i git clean -x -i ","date":"2016-08-19","objectID":"/2016/08/git-tools/:3:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"特殊合并 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:0","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"合并某个分支上的单个commit 假设将feature分支上的commitfdb7b6合并到master分支，不合并其它commit: 先查找想要合并的commit的SHA－1值； 再checkout到想要合并的分支； git checkout master 最后执行cherry-pick命令: git cherry-pick fdb7b6 ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:1","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["DevTools"],"content":"合并某个分支上的一系列commits 假设将feature分支上的commitfdb7b6 至d46ee6合并到master分支 首先，在feature分支基础上创建一个新分支，并且指明最后一个commit git checkout -b newBranch d46ee6 然后，使用rebase命令合并到master分支，要指明合并开始的commit git rebase --onto master fdb7b6^ to be continue... ","date":"2016-08-19","objectID":"/2016/08/git-tools/:4:2","tags":["Git"],"title":"Git命令使用记录-工具篇","uri":"/2016/08/git-tools/"},{"categories":["Java"],"content":"文章描述","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["Java"],"content":"问题背景 Java开发中，使用Hibernate作为映射数据库的表，所以创建了一个modle类 @javax.persistence.Entity @javax.persistence.Table(name = \"HibernateTest\") public class HibernateTest extends BaseModel { private static final long serialVersionUID = 9124938173965082237L; private Long id; private String name; private Integer age; @javax.persistence.Id @javax.persistence.GeneratedValue(strategy = javax.persistence.GenerationType.IDENTITY) @javax.persistence.Column(name = \"Id\") public Long getId() { return id; } public void setId(Long id) { this.id = id; } @javax.persistence.Column(name = \"Name\") public String getName() { return name; } public void setName(String name) { this.name = name; } @javax.persistence.Column(name = \"Age\") public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 对应的数据库，由于DBA要求非字符串字段必须有默认值，则 CREATE TABLE `HibernateTest` ( `Id` bigint(16) NOT NULL AUTO_INCREMENT COMMENT '主键', `Name` varchar(32) DEFAULT NULL COMMENT '名称', `Age` int(8) NOT NULL DEFAULT '-1' COMMENT '年龄', PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 这种情况下，使用Hibernate默认的save或update方法来添加或修改数据，如果有非空约束的字段(比如Age)没有赋值，会抛出异常。 因为Hibernate执行save或update时，会将映射类中的所有映射字段加入到生成的SQL语句中，所以导致数据库报错。 ","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/:1:0","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["Java"],"content":"解决方法 在映射类的类名上方，添加注解 @org.hibernate.annotations.Entity(dynamicInsert = true, dynamicUpdate = true) 这样Hibernate在执行save或update方法时，映射类中映射字段为NULL的，就不会加入到最后生成的SQL语句中了。 ","date":"2016-08-17","objectID":"/2016/08/java-hibernate-null-insert-mysql/:2:0","tags":["Hibernate"],"title":"MySQL表中字段有非空限制，Hibernate添加默认值","uri":"/2016/08/java-hibernate-null-insert-mysql/"},{"categories":["DevTools"],"content":"文章描述","date":"2016-08-16","objectID":"/2016/08/git-basics/","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"Git命令使用记录－来源自官方文档 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:0:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1. Git起步 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1.1 配置文件 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 用户信息 设置用户名称与邮件地址 git config --global user.name \"BruceMaa\" git config --global user.email BruceMaa@example.com 文本编辑器 默认是VIM，可配置为emacs git config --global core.editor emacs 检查配置信息 列出所有Git当时能找到的配置 git config --list Git会将三个位置的配置信息都列出来，所以可能会有重复，如果只想查看当前信息 git config user.name 打开当前仓库的配置文件 git config -e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"1.2 获取帮助 若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册: git help \u003cverb\u003e git \u003cverb\u003e --help man git-\u003cverb\u003e 例如，要想获得config命令的手册，执行 git help config ","date":"2016-08-16","objectID":"/2016/08/git-basics/:1:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2. Git基础 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.1 获取Git仓库 在现有目录中初始化仓库 初始化 git init 克隆仓库 克隆 git clone [url] 克隆仓库，自定义本地仓库名字 克隆，自定义本地仓库名字 git clone [url] [newRepo] ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.2 记录每次更新到仓库 检查当前文件状态 git status 跟踪新文件，并将文件暂存 git add file 交互式暂存 git add --interactive 等同于 git add -i 状态简览 git status -s ?? 表示新添加文件，但未跟踪 A 表示新添加文件，并放入暂存区中 左M 表示暂存区的文件已被修改，并放入暂存区中 右M 表示暂存区的文件已被修改，并未放入暂存区中 忽略文件 创建.gitignore文件，列出要忽略的文件模式，可用正则表达式 查看尚未暂存的文件更新了哪些部分 git diff 查看已暂存的文件未提交的更新部分 git diff --staged 提交更新 此命令提交，会显示core.editor设置的编辑器，填写提交信息 git commit 将提交信息于命令放在同一行 git commit -m \"new commit\" 不使用git add命令，将已跟踪过的文件暂存起来一并提交 git commit -a -m \"new commit\" 移除文件 git rm file 记得从工作目录中删除，这样就不会出现在未跟踪文件清单中了,如果已经放到暂存区的话，则要用强制删除选项 -f 从仓库中删除，但本地保留 git rm --cached file 移动文件 git mv file_from file_to ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.3 查看提交历史 git log -p 显示每次提交的内容差异，-2 显示最近两次提交 git log -p -2 –stat 查看每次提交的简略的统计信息 git log --stat –pretty 格式化显示内容，内建子选项 oneline, short, full和fuller git log --pretty=oneline 定制记录格式 git log --pretty=format:\"%h - %an, %ar : %s\" 显示精简SHA－1值 git log --abbrev-commit --pretty=oneline 引用日志 git reflog 查看5次前所指向的提交 git show HEAD@{5} 查看master分支昨天指向哪个提交 git show master@{yesterday} 父引用 需要在引用的后面加上一个^ HEAD的第一次父提交 git show HEAD^ HEAD的第二次父提交 git show HEAD^2 HEAD的第一次父提交的第一次父提交 git show HEAD^^ 等同于 git show HEAD~2 提交区间 双点 查看experiment分支上有哪些提交尚未合并到master分支上 git log master..experiment 查看在master分支中而不在experiment分支中的提交 git log experiment..master 查看即将推送到远端的内容,下面两个相同 git log origin/master..HEAD git log origin/master.. 多点 查看所有被refA或refB包含但是不被refC包含的提交，下面两个相同 git log refA refB ^refC git log refA refB --not refC 三点 查看master或者experiment中包含，但不是两者共有的的提交 git log master...experiment 还可以加参数–left-right，它会显示每一个提交属于哪一个分支 git log --left-right master...experiment format常用选项 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 当oneline或format与另一个log选项–graph结合使用时尤其有用，这个选项添加了一些ASCII字符串来形象的展示分支、合并历史： git log --pretty=format:\"%h %s\" --graph git log 的常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制git log 输出的选项 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令： git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" --before=\"2008-11-01\" --no-merges ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:3","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.4 撤销操作 更改上次提交 上次提交后发现有漏提交文件，将漏提交文件放到暂存区，然后执行命令 git commit --amend 取消暂存的文件 git reset HEAD \u003cfile\u003e 撤消对文件的修改 git checkout -- \u003cfile\u003e 撤消提交 撤消最近一次commit，数字可变。在这之后的commit全部舍弃 git reset --hard HEAD~1 撤消最近一次commit，数字可变，在这之后的commit都变成暂存状态，等待提交 git reset --soft HEAD~1 回滚最后一次提交 git reset --soft HEAD^ ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:4","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.5 远程仓库 查看原创仓库 git remote git remote -v 添加远程仓库 git remote add \u003cshortname\u003e \u003curl\u003e 从远程仓库拉取信息 git fetch \u003cshortname\u003e 从远程仓库抓取信息然后合并远程分支到当前分支 git pull 推送到远程仓库 git push [remote-name] [branch-name] 查看远程仓库 git remote show origin 重命名远程仓库 git remote rename \u003coldName\u003e \u003cnewName\u003e 移除远程仓库 git remote rm \u003cremote-name\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:5","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.6 打标签 列出标签 git tag 可以过滤结果 git tag -l 'v1.0.1*' 创建标签 附注标签 git tag -a v1.0 -m 'version 1.0' 轻量标签 git tag v1.0-rc 查看标签信息 git show \u003ctagName\u003e 后期打标签 git log --pertty=oneline 然后在打标签的命令后面加上该次提交的校验值(可以是部分) git tag -a V1.2 9fceb02 共享标签 git push origin \u003ctagname\u003e 如果想要一次推送很多标签 git push origin --tags 检出标签 git checkout -b \u003cbranchname\u003e \u003ctagname\u003e 删除标签 git push origin --delete tag \u003ctagname\u003e 或者，先本地删除标签，再将空标签推送到远程标签，等同于删除标签 git tag -d \u003ctagname\u003e git push origin :refs/tags/\u003ctagname\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:6","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"2.7 Git 别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status ","date":"2016-08-16","objectID":"/2016/08/git-basics/:2:7","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3 分支 ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:0","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.1 分支简介 分支创建 在当前所在的分支基础上创建新分支 git branch testing 分支切换 git checkout testing 查看分叉历史 git log --oneline --decorate --graph --all ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:1","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.2 分支的新建与合并 新建分支 git checkout -b iss53 等同于下面两条命令 git branch iss53 git checkout iss53 分支的合并 将iss53分支合并到master git checkout master git merge iss53 合并时有冲突 修改冲突后，需要查看文件状态，把未提交的提交 git status 删除分支 git branch -d hotfix ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:2","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.3 分支管理 分支列表 git branch 查看每一个分支的最后一次提交 git branch -v 查看哪些分支已经合并到当前分支 git branch --merged 查看所有包含未合并工作的分支 git branch --no-merged 强制删除未合并过的分支 git branch -D testing 重命名本地分支 git branch -m \u003coldBranchName\u003e \u003cnewBranchName\u003e ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:3","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.3 远程分支 查看远程仓库的远程分支 git ls-remote origin 推送本地分支到远程仓库 git push (remote) (branch) 推送本地分支到远程仓库，并且取不同名字 git push (remote) (local_branch):(new_branch) 跟踪分支 git checkout --track origin/serverfix 修改正在跟踪的上游分支 git branch -u origin/newBranch 或 git branch --set-upstream-to origin/newBranch 查看所有跟踪分支 git branch -vv 如果有显示远程分支显示，并且有ahead提示，则有未推送到远程分支，有behind则表示远程服务器有提交未合并到本地，都没有则表示和远程分支同步； 如果没有显示远程分支，则表示未跟踪远程分支。 如果想查看最新情况，则需要先抓取所有远程仓库，再查看: git fetch --all 拉取 git pull 等同于 git fetch;git merge 删除远程分支 git push origin --delete \u003cdelBranch\u003e 或者，推送一个空分支到远程分支，等同于删除远程分支 git push origin :\u003cdelBranch\u003e 删除本地仓库中，远程已经删除的分支 远程删除了某个分支，本地执行抓取或者拉取时，并不会将本地对应的该分支也一并删除，使用 git remote show origin 命令查看时，正常的跟踪分支状态为tracked，已删除的分支状态为stale，并且Git提示可以使用命令删除 git remote prune 还有一种简单的命令 git fetch -p ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:4","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"},{"categories":["DevTools"],"content":"3.4 变基 变基的基本操作 检出新分支，coding git checkout experiment 变基到想要合并的分支 git rebase master 回到master分支 git checkout master 快进合并 git merge experiment 多重分支变基 从master分支创建server分支，再从server创建client分支，现在想先将client分支变基到master分支,再快进合并： git rebase --onto master server client git checkout master git merge client 再将server分支变基到master分支，再快进合并 git rebase master server git merge server 不需切换分支，直接变基某个分支 git rebase [basebranch] [topicbranch] ","date":"2016-08-16","objectID":"/2016/08/git-basics/:3:5","tags":["Git"],"title":"Git命令使用记录-基础篇","uri":"/2016/08/git-basics/"}]